		; serial-port ROM monitor/boot for debugging Kaypro.
		; Uses "aux serial" a.k.a "Serial Printer" port.
		
0017          	VERN	equ	017h	; ROM version
		
0800          	romsiz	equ	0800h	; minimum space for ROM
		
			maclib	z80
**** z80.lib ****
**** monitor.asm ****
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0003          	CTLC	equ	3
0007          	BEL	equ	7
0009          	TAB	equ	9
0008          	BS	equ	8
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
		; WD1943 at 5.0688MHz...
000E          	B9600	equ	0eh
0005          	B300	equ	05h
		; */84 (and 10) sysport drive select
0002          	DS0	equ	0010b
0001          	DS1	equ	0001b
0003          	DSNONE	equ	0011b	; also mask
0010          	MTRON	equ	10000b	; MOTOR control
		
0004          	sio1	equ	04h	; "serial data", "keyboard"
000C          	sio2	equ	0ch	; "serial printer", "modem"
0000          	brd1	equ	00h
0008          	brd2	equ	08h
		
0000          	sioA	equ	00h	; offsets
0001          	sioB	equ	01h
		
0000          	sioD	equ	00h	; offsets
0002          	sioC	equ	02h
		
		; Choose Z80SIO port to use...
0004          	condat	equ	sio1+sioA+sioD
0006          	conctl	equ	sio1+sioA+sioC
0000          	conbrr	equ	brd1
		
0005          	kbddat	equ	sio1+sioB+sioD
0007          	kbdctl	equ	sio1+sioB+sioC
000C          	kbdbrr	equ	0ch	; */83 uses WD1943, else hardwired to 300 baud
		
001C          	crtctl	equ	1ch	; */84 and 10 only
001D          	crtdat	equ	1dh	; */84 and 10 only
001F          	crtram	equ	1fh	; also accesses CRTC
		
0014          	sysp84	equ	14h	; sysport on */84 (and 10). */83 have nothing here.
		
0000          	stack	equ	00000h	; stack at top of memory (wrapped)
		
		; Start of ROM code
0000          		org	00000h
0008          	rst0e	equ	$+8
0000  C36A00  		jmp	init
0003  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0010          	rst1e	equ	$+8
0008  C34B00  	rst1:	jmp	swtrap
000B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0018          	rst2e	equ	$+8
0010  C34B00  	rst2:	jmp	swtrap
0013  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0020          	rst3e	equ	$+8
0018  C34B00  	rst3:	jmp	swtrap
001B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0028          	rst4e	equ	$+8
0020  C34B00  	rst4:	jmp	swtrap
0023  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0030          	rst5e	equ	$+8
0028  C34B00  	rst5:	jmp	swtrap
002B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0038          	rst6e	equ	$+8
0030  C34B00  	rst6:	jmp	swtrap
0033  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0040          	rst7e	equ	$+8
0038  C34B00  	rst7:	jmp	swtrap
003B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
			; NMI not a problem?
		
0040  0D0A2A2A	swt:	db	CR,LF,'*** RST ',TRM
      2A205253
      542000
		
004B  F3      	swtrap:	di		; try to recover return address...
004C  D1      		pop	d	; should be caller of RST...
004D  310000  		lxi	sp,stack
0050  D5      		push	d	; not needed?
0051  214000  		lxi	h,swt
0054  CD4A06  		call	msgprt
0057  D1      		pop	d
0058  CD2106  		call	taddr
005B  CD4006  		call	crlf
			; TODO: print address, etc...
005E  C3DC00  		jmp	debug
		
0061  18      	sioini:	db	18h	; reset
0062  0444    		db	4,044h	;
0064  03C1    		db	3,0c1h	;
0066  05E8    		db	5,0e8h	;
0068  0100    		db	1,000h	;
0009          	siolen	equ	$-sioini
		
		; ROM start point - initialize everything
		; We know we have 64K RAM...
006A  F3      	init:	di
006B  310000  		lxi	sp,stack
		
			; init serial port
006E  3E0E    		mvi	a,B9600
0070  D300    		out	conbrr
0072  216100  		lxi	h,sioini
0075  0E06    		mvi	c,conctl
0077  0609    		mvi	b,siolen
0079          		outir
0079  EDB3    		DB	0EDH,0B3H
		
007B  21BF00  		lxi	h,signon
007E  CD4A06  		call	msgprt
		
0081  CD0207  		call	proginit
			; save registers on stack, for debugger access...
0084  C3DC00  		jmp	debug
		
0087          	belout:
0087  0E07    		mvi	c,BEL
		; Output char to console
		; C=char
0089          	conout:
0089  DB06    		in	conctl
008B  E604    		ani	00000100b
008D          		jrz	conout
008D  28FA    		DB	28H,conout-$-1
008F  79      		mov	a,c
0090  D304    		out	condat
0092  C9      		ret
		
0093  0D0A3A20	prompt:	db	CR,LF,': ',TRM
      00
		
		; Get char from console
		; Returns: A=char, stripped
0098  E5      	conin:	push	h
0099  210000  	ci2:	lxi	h,0
009C  DB06    	ci0:	in	conctl		; 11
009E  E601    		ani	00000001b	;  7
00A0          		jrnz	ci1		;  7
00A0  200A    		DB	20H,ci1-$-1
00A2  2B      		dcx	h		;  6
00A3  7D      		mov	a,l		;  4
00A4  B4      		ora	h		;  4
00A5          		jrnz	ci0		; 12 = 51 (12.75uS) (~0.8 sec)
00A5  20F5    		DB	20H,ci0-$-1
00A7  CD1207  		call	progress	; on */83 (20.4uS or ~1.3 sec)
00AA          		jr	ci2
00AA  18ED    		DB	18H,ci2-$-1
00AC  DB04    	ci1:	in	condat
00AE  E67F    		ani	07fh
00B0  E1      		pop	h
00B1  C9      		ret
		
		; Get char from console, toupper and echo
00B2          	conine:
00B2  CD9800  		call	conin
00B5  CD6506  		call	toupper
00B8  F5      		push	psw
00B9  4F      		mov	c,a
00BA  CD8900  		call	conout
00BD  F1      		pop	psw
00BE  C9      		ret
		
00BF  0D0A4B61	signon:	db	CR,LF,'Kaypro Monitor v'
      7970726F
      204D6F6E
      69746F72
      2076
00D1  312E37  	vernum:	db	(VERN SHR 4)+'0','.',(VERN AND 0fh)+'0'
00D4  0D0A00  		db	CR,LF,TRM
		
00D7  0D0A073F	errm:	db	CR,LF,BEL,'?',TRM
      00
		
		*********************************************************
		**  Debug mode
		*********************************************************
		
00DC          	debug:
00DC  310000  	cilp:	lxi	sp,stack
00DF  21DC00  		lxi	h,cilp		;setup return address
00E2  E5      		push	h
00E3  219300  		lxi	h,prompt	;prompt for a command
00E6  CD4A06  		call	msgprt
00E9  CD6E06  		call	linein		;wait for command line to be entered
00EC  1104FF  		lxi	d,line
00EF  CDBC06  		call	char		;get first character
00F2  C8      		rz			;ignore line if it is empty
00F3  210D01  		lxi	h,comnds	;search table for command character
00F6  060B    		mvi	b,ncmnds	;(number of commands)
00F8  BE      	cci0:	cmp	m		;search command table
00F9  23      		inx	h
00FA          		jrz	gotocmd		;command was found, execute it
00FA  280A    		DB	28H,gotocmd-$-1
00FC  23      		inx	h		;step past routine address
00FD  23      		inx	h
00FE          		djnz	cci0		;loop untill all valid commands are checked
00FE  10F8    		DB	10H,cci0-$-1
0100  21D700  	error:	lxi	h,errm		;if command unknown, beep and re-prompt
0103  C34A06  		jmp	msgprt
		
0106          	gotocmd:
0106  D5      		push	d		;save command line buffer pointer
0107  5E      		mov	e,m		;get command routine address
0108  23      		inx	h
0109  56      		mov	d,m		;DE = routine address
010A  EB      		xchg			;HL = routine address
010B  D1      		pop	d		;restore buffer pointer
010C  E9      		pchl			;jump to command routine
		
		; All commands are started with DE=next char in line buffer
010D          	comnds:
010D  3F      		db	'?'
010E  DB02    		dw	Qcomnd
0110  44      		db	'D'
0111  8303    		dw	Dcomnd
0113  53      		db	'S'
0114  E903    		dw	Scomnd
0116  47      		db	'G'
0117  5104    		dw	Gcomnd
0119  4D      		db	'M'
011A  E202    		dw	Mcomnd
011C  46      		db	'F'
011D  4303    		dw	Fcomnd
011F  49      		db	'I'
0120  8904    		dw	Icomnd
0122  4F      		db	'O'
0123  DB04    		dw	Ocomnd
0125  4E      		db	'N'
0126  1005    		dw	Ncomnd
0128  54      		db	'T'
0129  8905    		dw	Tcomnd
012B  56      		db	'V'
012C  1B06    		dw	Vcomnd
000B          	ncmnds	equ	($-comnds)/3
		
		*********************************************************
		**  Command subroutines
		*********************************************************
		
012E          	menu:
012E  0D0A4420		db	CR,LF,'D <start> <end> - display memory in HEX'
      3C737461
      72743E20
      3C656E64
      3E202D20
      64697370
      6C617920
      6D656D6F
      72792069
      6E204845
      58
0157  0D0A5320		db	CR,LF,'S <start> - set/view memory'
      3C737461
      72743E20
      2D207365
      742F7669
      6577206D
      656D6F72
      79
0174  0D0A2020		db	CR,LF,'    (CR) = skip fwd, ''-'' = skip bkwd, ''.'' = done'
      20202843
      5229203D
      20736B69
      70206677
      642C2027
      2D27203D
      20736B69
      7020626B
      77642C20
      272E2720
      3D20646F
      6E65
01A6  0D0A4720		db	CR,LF,'G <start> - go to address'
      3C737461
      72743E20
      2D20676F
      20746F20
      61646472
      657373
01C1  0D0A4620		db	CR,LF,'F <start> <end> <data> - fill memory'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6174613E
      202D2066
      696C6C20
      6D656D6F
      7279
01E7  0D0A4D20		db	CR,LF,'M <start> <end> <dest> - Move data'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6573743E
      202D204D
      6F766520
      64617461
020B  0D0A4920		db	CR,LF,'I <port> [num] - Input from port'
      3C706F72
      743E205B
      6E756D5D
      202D2049
      6E707574
      2066726F
      6D20706F
      7274
022D  0D0A4F20		db	CR,LF,'O <port> <value> [...] - Output to port'
      3C706F72
      743E203C
      76616C75
      653E205B
      2E2E2E5D
      202D204F
      75747075
      7420746F
      20706F72
      74
0256  0D0A4E20		db	CR,LF,'N <hw> - iNitialize hardware (KB83, KB84, CRTC)'
      3C68773E
      202D2069
      4E697469
      616C697A
      65206861
      72647761
      72652028
      4B423833
      2C204B42
      38342C20
      43525443
      29
0287  0D0A5420		db	CR,LF,'T <hw> - Test hardware (KBD, CRTC)'
      3C68773E
      202D2054
      65737420
      68617264
      77617265
      20284B42
      442C2043
      52544329
02AB  0D0A5620		db	CR,LF,'V - Show ROM version'
      2D205368
      6F772052
      4F4D2076
      65727369
      6F6E
02C1  0D0A5E43		db	CR,LF,'^C aborts command entry'
      2061626F
      72747320
      636F6D6D
      616E6420
      656E7472
      79
02DA  00      		db	TRM
		
02DB          	Qcomnd:
02DB  212E01  		lxi	h,menu
02DE  CD4A06  		call	msgprt
02E1  C9      		ret
		
02E2  CDC806  	Mcomnd:	call	getaddr
02E5  DA0001  		jc	error
02E8          		bit	7,b
02E8  CB78    		DB	0CBH,7*8+b+40H
02EA  C20001  		jnz	error
02ED  2200FF  		shld	addr0
02F0  CDC806  		call	getaddr
02F3  DA0001  		jc	error
02F6          		bit	7,b
02F6  CB78    		DB	0CBH,7*8+b+40H
02F8  C20001  		jnz	error
02FB  2202FF  		shld	addr1
02FE  CDC806  		call	getaddr
0301  DA0001  		jc	error
0304          		bit	7,b
0304  CB78    		DB	0CBH,7*8+b+40H
0306  C20001  		jnz	error
0309  EB      		xchg
030A          		lbcd	addr0
030A  ED4B    		DB	0EDH,4BH
030C  00FF    		DW	addr0
030E  2A02FF  		lhld	addr1
0311  B7      		ora	a
0312          		dsbc	b
0312  ED42    		DB	0EDH,b*8+42H
0314  DA0001  		jc	error
0317  23      		inx	h
0318  4D      		mov	c,l
0319  44      		mov	b,h
031A  D5      		push	d
031B  EB      		xchg
031C  09      		dad	b
031D  D1      		pop	d
031E  DA0001  		jc	error
0321  2A02FF  		lhld	addr1
0324  CD5F06  		call	check
0327  DA3D03  		jc	mc0
032A  2A00FF  		lhld	addr0
032D  CD5F06  		call	check
0330  D23D03  		jnc	mc0
0333  2A02FF  		lhld	addr1
0336  EB      		xchg
0337  09      		dad	b
0338  2B      		dcx	h
0339  EB      		xchg
033A          		lddr
033A  EDB8    		DB	0EDH,0B8H
033C  C9      		ret
033D  2A00FF  	mc0:	lhld	addr0
0340          		ldir
0340  EDB0    		DB	0EDH,0B0H
0342  C9      		ret
0343          	Fcomnd:
0343  CDC806  		call	getaddr ;get address to start at
0346  DA0001  		jc	error	;error if non-hex character
0349          		bit	7,b	;test for no address (different from 0000)
0349  CB78    		DB	0CBH,7*8+b+40H
034B  C20001  		jnz	error	;error if no address was entered
034E  2200FF  		shld	addr0	;save starting address
0351  CDC806  		call	getaddr ;get stop address
0354  DA0001  		jc	error	;error if non-hex character
0357          		bit	7,b	;test for no entry
0357  CB78    		DB	0CBH,7*8+b+40H
0359  C20001  		jnz	error	;error if no stop address
035C  2202FF  		shld	addr1	;save stop address
035F  CDC806  		call	getaddr ;get fill data
0362  DA0001  		jc	error	;error if non-hex character
0365          		bit	7,b	;test for no entry
0365  CB78    		DB	0CBH,7*8+b+40H
0367  C20001  		jnz	error	;error if no fill data
036A  7C      		mov	a,h
036B  B7      		ora	a
036C  C20001  		jnz	error
036F  4D      		mov	c,l	;(C)=fill data
0370  2A02FF  		lhld	addr1	;get stop address
0373          		lded	addr0	;get start address
0373  ED5B    		DB	0EDH,5BH
0375  00FF    		DW	addr0
0377  79      	fc0:	mov	a,c	;
0378  12      		stax	d	;put byte in memory
0379  13      		inx	d	;step to next byte
037A  7A      		mov	a,d	;
037B  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
037C  C8      		rz		;
037D  CD5F06  		call	check	;test for past stop address
0380  D8      		rc	;quit if past stop address
0381          		jr	fc0
0381  18F4    		DB	18H,fc0-$-1
		
0383          	Dcomnd:		;display memory
0383  CDC806  		call	getaddr ;get address to start at
0386  DA0001  		jc	error	;error if non-hex character
0389          		bit	7,b	;test for no address (different from 0000)
0389  CB78    		DB	0CBH,7*8+b+40H
038B  C20001  		jnz	error	;error if no address was entered
038E  2200FF  		shld	addr0	;save starting address
0391  CDC806  		call	getaddr ;get stop address
0394  DA0001  		jc	error	;error if non-hex character
0397          		bit	7,b	;test for no entry
0397  CB78    		DB	0CBH,7*8+b+40H
0399  C20001  		jnz	error	;error if no stop address
039C          		lded	addr0	;get start address into (DE)
039C  ED5B    		DB	0EDH,5BH
039E  00FF    		DW	addr0
03A0  CD4006  	dis0:	call	crlf	;start on new line
03A3  CD2106  		call	taddr	;print current address
03A6  CD3B06  		call	space	;delimit it from data
03A9  0610    		mvi	b,16	;display 16 bytes on each line
03AB  1A      	dis1:	ldax	d	;get byte to display
03AC  13      		inx	d	;step to next byte
03AD  CD2606  		call	hexout	;display this byte in HEX
03B0  CD3B06  		call	space	;delimit it from others
03B3  7A      		mov	a,d
03B4  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03B5          		jrz	dis2
03B5  2807    		DB	28H,dis2-$-1
03B7  CD5F06  		call	check	;test for past stop address
03BA          		jrc	dis2	;quit if past stop address
03BA  3802    		DB	38H,dis2-$-1
03BC          		djnz	dis1	;else do next byte on this line
03BC  10ED    		DB	10H,dis1-$-1
03BE  CD3B06  	dis2:	call	space	;delimit it from data
03C1  CD3B06  		call	space
03C4          		lded	addr0
03C4  ED5B    		DB	0EDH,5BH
03C6  00FF    		DW	addr0
03C8  0610    		mvi	b,16	;display 16 bytes on each line
03CA  1A      	dis3:	ldax	d	;get byte to display
03CB  13      		inx	d	;step to next byte
03CC  0E2E    		mvi	c,'.'
03CE  FE20    		cpi	' '
03D0          		jrc	dis4
03D0  3805    		DB	38H,dis4-$-1
03D2  FE7F    		cpi	'~'+1
03D4          		jrnc	dis4
03D4  3001    		DB	30H,dis4-$-1
03D6  4F      		mov	c,a
03D7  CD8900  	dis4:	call	conout
03DA  7A      		mov	a,d
03DB  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03DC  C8      		rz
03DD  CD5F06  		call	check	;test for past stop address
03E0  D8      		rc	;quit if past stop address
03E1          		djnz	dis3	;else do next byte on this line
03E1  10E7    		DB	10H,dis3-$-1
03E3          		sded	addr0
03E3  ED53    		DB	0EDH,53H
03E5  00FF    		DW	addr0
03E7          		jr	dis0	;when line is finished, start another
03E7  18B7    		DB	18H,dis0-$-1
		
03E9          	Scomnd: 		;substitute (set) memory
03E9  CDC806  		call	getaddr ;get address to start substitution at
03EC  DA0001  		jc	error	;error if non-hex character
03EF          		bit	7,b	;test for no entry
03EF  CB78    		DB	0CBH,7*8+b+40H
03F1  C20001  		jnz	error	;error if no address
03F4  EB      		xchg		;put address in (DE)
03F5  CD4006  	sb1:	call	crlf	;start on new line
03F8  CD2106  		call	taddr	;print address
03FB  CD3B06  		call	space	;and delimit it
03FE  1A      		ldax	d	;get current value of byte
03FF  CD2606  		call	hexout	;and display it
0402  CD3B06  		call	space	;delimit it from user's (posible) entry
0405  0600    		mvi	b,0	;zero accumilator for user's entry
0407  CDB200  	sb2:	call	conine	;get user's first character
040A  FE0D    		cpi	CR	;if CR then skip to next byte
040C          		jrz	foward
040C  2833    		DB	28H,foward-$-1
040E  FE20    		cpi	' '	;or if Space then skip to next
0410          		jrz	foward
0410  282F    		DB	28H,foward-$-1
0412  FE2D    		cpi	'-'	;if Minus then step back to previous address
0414          		jrz	bakwrd
0414  282E    		DB	28H,bakwrd-$-1
0416  FE2E    		cpi	'.'	;if Period then stop substitution
0418  C8      		rz
0419  CDEF06  		call	hexcon	;if none of the above, should be HEX digit
041C          		jrc	error0	;error if not
041C  3829    		DB	38H,error0-$-1
041E          		jr	sb3	;start accumilating HEX digits
041E  1805    		DB	18H,sb3-$-1
0420  CDEF06  	sb0:	call	hexcon	;test for HEX digit
0423          		jrc	error1	;error if not HEX
0423  3827    		DB	38H,error1-$-1
0425          	sb3:	slar	b	;roll accumilator to receive new digit
0425  CB20    		DB	0CBH, 20H + b
0427          		slar	b
0427  CB20    		DB	0CBH, 20H + b
0429          		slar	b
0429  CB20    		DB	0CBH, 20H + b
042B          		slar	b
042B  CB20    		DB	0CBH, 20H + b
042D  B0      		ora	b	;merge in new digit
042E  47      		mov	b,a
042F  CDB200  	sb4:	call	conine	;get next character
0432  FE0D    		cpi	CR	;if CR then put existing byte into memory
0434          		jrz	putbyte ;  and step to next.
0434  2809    		DB	28H,putbyte-$-1
0436  FE2E    		cpi	'.'
0438  C8      		rz
0439  FE7F    		cpi	del	;if DEL then restart at same address
043B          		jrz	sb1
043B  28B8    		DB	28H,sb1-$-1
043D          		jr	sb0	;else continue entering hex digits
043D  18E1    		DB	18H,sb0-$-1
043F          	putbyte:
043F  78      		mov	a,b	;store accumilated byte in memory
0440  12      		stax	d
0441          	foward:
0441  13      		inx	d	;step to next location
0442          		jr	sb1	;and allow substitution there
0442  18B1    		DB	18H,sb1-$-1
		
0444          	bakwrd:
0444  1B      		dcx	d	;move address backward one location
0445          		jr	sb1
0445  18AE    		DB	18H,sb1-$-1
		
0447  CD8700  	error0:	call	belout	;user's entry was not valid, beep and continue
044A          		jr	sb2
044A  18BB    		DB	18H,sb2-$-1
044C  CD8700  	error1:	call	belout	;same as above but for different section of routine
044F          		jr	sb4
044F  18DE    		DB	18H,sb4-$-1
		
0451          	Gcomnd: 		;jump to address given by user
0451  CDC806  		call	getaddr ;get address to jump to
0454  DA0001  		jc	error	;error if non-hex character
0457          		bit	7,b	;test for no entry
0457  CB78    		DB	0CBH,7*8+b+40H
0459  C20001  		jnz	error	;error if no address entered
045C  CD4006  		call	crlf	;on new line,
045F  0E47    		mvi	c,'G'	;display "GO aaaa?" to ask
0461  CD8900  		call	conout	;user to verify that we should
0464  0E4F    		mvi	c,'O'	;jump to this address (in case user
0466  CD8900  		call	conout	;made a mistake we should not blindly
0469  CD3B06  		call	space	;commit suicide)
046C  EB      		xchg
046D  CD2106  		call	taddr
0470  CD3B06  		call	space
0473  0E3F    		mvi	c,'?'
0475  CD8900  		call	conout
0478  CDB200  		call	conine	;wait for user to type "Y" to
047B  FE59    		cpi	'Y'	;indicate that we should jump.
047D  C0      		rnz		;abort if response was not "Y"
047E  EB      		xchg
047F  E9      		pchl		;else jump to address
		
0480  0D0A496E	inpms:	db	CR,LF,'Input ',TRM
      70757420
      00
0489          	Icomnd:
0489  CDC806  		call	getaddr ;get port address, ignore extra MSDs
048C  DA0001  		jc	error	;error if non-hex character
048F          		bit	7,b	;test for no entry
048F  CB78    		DB	0CBH,7*8+b+40H
0491  C20001  		jnz	error	;error if no address entered
0494  E5      		push	h	; save port
0495  CDC806  		call	getaddr	; hex number of inputs to do
0498  DA0001  		jc	error
049B          		bit	7,b
049B  CB78    		DB	0CBH,7*8+b+40H
049D          		jrz	ic0
049D  2803    		DB	28H,ic0-$-1
049F  210100  		lxi	h,1
04A2          	ic0:
04A2  E3      		xthl		; save count
04A3  E5      		push	h	; re-save port
04A4  218004  		lxi	h,inpms
04A7  CD4A06  		call	msgprt
04AA  E1      		pop	h
04AB  E5      		push	h
04AC  7D      		mov	a,l
04AD  CD2606  		call	hexout
04B0  CD3B06  		call	space
04B3  0E3D    		mvi	c,'='
04B5  CD8900  		call	conout
			; "Input XX ="
04B8  C1      		pop	b	; port to BC
04B9  E1      		pop	h	; count to HL (L)
04BA  260D    		mvi	h,16-3
04BC  0600    		mvi	b,0	; safety
04BE  C5      		push	b	; C gets trashed by conout
04BF          	ic1:
04BF  CD3B06  		call	space
04C2  C1      		pop	b
04C3  C5      		push	b
04C4          		inp	a
04C4  ED78    		DB	0EDH,a*8+40H
04C6  CD2606  		call	hexout
04C9  2D      		dcr	l	; assume <= 256
04CA          		jrz	ic2
04CA  280A    		DB	28H,ic2-$-1
04CC  25      		dcr	h	; col count
04CD          		jrnz	ic1
04CD  20F0    		DB	20H,ic1-$-1
04CF  CD4006  		call	crlf
04D2  2610    		mvi	h,16
04D4          		jr	ic1
04D4  18E9    		DB	18H,ic1-$-1
04D6          	ic2:
04D6  C1      		pop	b	; fix stack
04D7  CD4006  		call	crlf
04DA  C9      		ret
		
		; TODO: no feedback?
04DB          	Ocomnd:
04DB  CDC806  		call	getaddr ;get port address, ignore extra MSDs
04DE  DA0001  		jc	error	;error if non-hex character
04E1          		bit	7,b	;test for no entry
04E1  CB78    		DB	0CBH,7*8+b+40H
04E3  C20001  		jnz	error	;error if no address entered
04E6  2600    		mvi	h,0	; safety
04E8  E5      		push	h	; save port
04E9  CDC806  		call	getaddr ;get value, ignore extra MSDs
04EC  DA0001  		jc	error	;error if non-hex character
04EF          		bit	7,b	;test for no entry
04EF  CB78    		DB	0CBH,7*8+b+40H
04F1  C20001  		jnz	error	;error if no value entered
04F4  CD4006  		call	crlf
04F7          	oc0:		; L has byte to output...
04F7  C1      		pop	b	; port
04F8  C5      		push	b
04F9          		outp	l
04F9  ED69    		DB	0EDH,l*8+41H
04FB  CDC806  		call	getaddr ;get value, ignore extra MSDs
04FE  DA0001  		jc	error	;error if non-hex character
					;NOTE: some output has been sent
0501          		bit	7,b	;test for no entry
0501  CB78    		DB	0CBH,7*8+b+40H
0503          		jrz	oc0	;still more to send
0503  28F2    		DB	28H,oc0-$-1
0505  E1      		pop	h	; discard port
0506  C9      		ret
		
0507  CDBC06  	skb:	call	char
050A  C8      		rz		;end of buffer/line before a character was found (ZR)
050B  FE20    		cpi	' '	;skip all leading spaces
050D  C0      		rnz		;if not space, then done (NZ)
050E          		jr	skb	;else if space, loop untill not space
050E  18F7    		DB	18H,skb-$-1
		
0510          	Ncomnd:
0510  CD0705  		call	skb	; skip blanks
0513  CA0001  		jz	error	; required param
			; this may need refinement
0516  1B      		dcx	d
0517  213205  		lxi	h,kb83
051A  CD7905  		call	strcmp
051D          		jrz	nkb83
051D  2826    		DB	28H,nkb83-$-1
051F  213705  		lxi	h,kb84
0522  CD7905  		call	strcmp
0525          		jrz	nkb84
0525  2822    		DB	28H,nkb84-$-1
0527  213C05  		lxi	h,crtc
052A  CD7905  		call	strcmp
052D          		jrz	ncrtc
052D  2824    		DB	28H,ncrtc-$-1
052F  C30001  		jmp	error
		
0532  4B423833	kb83:	db	'KB83',TRM
      00
0537  4B423834	kb84:	db	'KB84',TRM
      00
053C  43525443	crtc:	db	'CRTC',TRM
      00
0541  4B424400	kbd:	db	'KBD',TRM
		
0545  3E05    	nkb83:	mvi	a,B300
0547  D30C    		out	kbdbrr	; */83 baud gen for SIO1 ch B
0549  216100  	nkb84:	lxi	h,sioini
054C  0E07    		mvi	c,kbdctl
054E  0609    		mvi	b,siolen
0550          		outir
0550  EDB3    		DB	0EDH,0B3H
0552  C9      		ret
		
0553  216905  	ncrtc:	lxi	h,crtini
0556  0E1D    		mvi	c,crtdat	; */84 CRTC 6545 data port
0558  0610    		mvi	b,16
055A  AF      		xra	a	; start with reg 00
055B  0D      	nc0:	dcr	c
055C          		outp	a	; select reg
055C  ED79    		DB	0EDH,a*8+41H
055E  3C      		inr	a	; ++reg
055F  0C      		inr	c	;
0560          		outi
0560  EDA3    		DB	0EDH,0A3H
0562          		jrnz	nc0
0562  20F7    		DB	20H,nc0-$-1
0564  3E1F    		mvi	a,31	; R31 enables CRTC
0566  D31C    		out	crtctl
0568  C9      		ret
		
0569  6A505699	crtini:	db	6ah,50h,56h,99h,19h,0ah,19h,19h,78h,0fh,60h,0fh,00h,00h,00h,00h
      190A1919
      780F600F
      00000000
		
0579  D5      	strcmp:	push	d
057A  AF      		xra	a
057B  BE      	sc0:	cmp	m	; TRM?
057C          		jrz	sc9	; A = 0
057C  2808    		DB	28H,sc9-$-1
057E  1A      		ldax	d
057F  96      		sub	m
0580          		jrnz	sc9	; A is NZ
0580  2004    		DB	20H,sc9-$-1
0582  23      		inx	h
0583  13      		inx	d
0584          		jr	sc0
0584  18F5    		DB	18H,sc0-$-1
0586  D1      	sc9:	pop	d
0587  B7      		ora	a
0588  C9      		ret
		
0589          	Tcomnd:
0589  CD0705  		call	skb	; skip blanks
058C  CA0001  		jz	error	; required param
			; this may need refinement
058F  1B      		dcx	d
0590  214105  		lxi	h,kbd
0593  CD7905  		call	strcmp
0596          		jrz	tkbd
0596  2846    		DB	28H,tkbd-$-1
0598  213C05  		lxi	h,crtc
059B  CD7905  		call	strcmp
059E          		jrz	tcrtc
059E  2803    		DB	28H,tcrtc-$-1
05A0  C30001  		jmp	error
		
05A3  210306  	tcrtc:	lxi	h,waitm
05A6  CD4A06  		call	msgprt
05A9  0605    		mvi	b,5	; count
05AB  1E80    		mvi	e,80h	; compare
05AD  3E1F    		mvi	a,31
05AF  D31C    		out	crtctl	; select reg
05B1  DB1C    	tc0:	in	crtctl
05B3  E680    		ani	80h
05B5  BB      		cmp	e
05B6          		jrz	tc9
05B6  280F    		DB	28H,tc9-$-1
05B8  DB06    		in	conctl
05BA  E601    		ani	00000001b
05BC          		jrz	tc0
05BC  28F3    		DB	28H,tc0-$-1
05BE  DB04    		in	condat
05C0  210E06  		lxi	h,abrtm
05C3  CD4A06  		call	msgprt
05C6  C9      		ret
05C7  7B      	tc9:	mov	a,e
05C8  EE80    		xri	80h
05CA  5F      		mov	e,a
05CB          		jrnz	tc8
05CB  200B    		DB	20H,tc8-$-1
05CD  211406  		lxi	h,updtm
05D0  CD4A06  		call	msgprt
05D3  DB1F    		in	crtram	; clear Update
05D5          		djnz	tc0
05D5  10DA    		DB	10H,tc0-$-1
05D7  C9      		ret
05D8  CD3B06  	tc8:	call	space
05DB          		djnz	tc0
05DB  10D4    		DB	10H,tc0-$-1
05DD  C9      		ret
		
05DE  210306  	tkbd:	lxi	h,waitm
05E1  CD4A06  		call	msgprt
05E4  DB07    	tk0:	in	kbdctl
05E6  E601    		ani	00000001b
05E8          		jrnz	tk1
05E8  200F    		DB	20H,tk1-$-1
05EA  DB06    		in	conctl
05EC  E601    		ani	00000001b
05EE          		jrz	tk0
05EE  28F4    		DB	28H,tk0-$-1
05F0  DB04    		in	condat
05F2  210E06  		lxi	h,abrtm
05F5  CD4A06  		call	msgprt
05F8  C9      		ret
05F9  DB05    	tk1:	in	kbddat
05FB  CD2606  		call	hexout
05FE  CD3B06  		call	space
0601          		jr	tk0
0601  18E1    		DB	18H,tk0-$-1
		
0603  0D0A5761	waitm:	db	CR,LF,'Wait... ',TRM
      69742E2E
      2E2000
060E  41626F72	abrtm:	db	'Abort',TRM
      7400
0614  55706461	updtm:	db	'Update',TRM
      746500
		
061B          	Vcomnd:
061B  21BF00  		lxi	h,signon
061E  C34A06  		jmp	msgprt
		
		*********************************************************
		**  Utility subroutines
		*********************************************************
		
0621  7A      	taddr:	mov	a,d	;display (DE) at console in HEX
0622  CD2606  		call	hexout	;print HI byte in HEX
0625  7B      		mov	a,e	;now do LO byte
0626  F5      	hexout:	push	psw	;output (A) to console in HEX
0627  07      		rlc		;get HI digit in usable (LO) position
0628  07      		rlc
0629  07      		rlc
062A  07      		rlc
062B  CD2F06  		call	nible	;and display it
062E  F1      		pop	psw	;get LO digit back and display it
062F  E60F    	nible:	ani	00001111b	;display LO 4 bits of (A) in HEX
0631  C690    		adi	90h	;algorithm to convert 4-bits to ASCII
0633  27      		daa
0634  CE40    		aci	40h
0636  27      		daa
0637  4F      		mov	c,a	;display ASCII digit
0638  C38900  		jmp	conout
		
063B  0E20    	space:	mvi	c,' '	;send an ASCII blank to console
063D  C38900  		jmp	conout
		
0640  0E0D    	crlf:	mvi	c,CR	;send Carriage-Return/Line-Feed to console
0642  CD8900  		call	conout
0645  0E0A    		mvi	c,LF
0647  C38900  		jmp	conout
		
064A  7E      	msgprt:	mov	a,m	;send string to console, terminated by 00
064B  B7      		ora	a
064C  C8      		rz
064D  4F      		mov	c,a
064E  CD8900  		call	conout
0651  23      		inx	h
0652          		jr	msgprt
0652  18F6    		DB	18H,msgprt-$-1
		
0654  7E      	print:	mov	a,m	; BDOS func 9 style msgprt
0655  FE24    		cpi	'$'
0657  C8      		rz
0658  4F      		mov	c,a
0659  CD8900  		call	conout
065C  23      		inx	h
065D          		jr	print
065D  18F5    		DB	18H,print-$-1
		
065F  E5      	check:	push	h	;non-destuctive compare HL:DE
0660  B7      		ora	a
0661          		dsbc	d
0661  ED52    		DB	0EDH,d*8+42H
0663  E1      		pop	h
0664  C9      		ret
		
		; Convert letters to upper-case
0665          	toupper:
0665  FE61    		cpi	'a'
0667  D8      		rc
0668  FE7B    		cpi	'z'+1
066A  D0      		rnc
066B  E65F    		ani	01011111b
066D  C9      		ret
		
		; Read a line of text into 'line'
		; End with CR, honor BS
		; Reject all non-printing characters, force toupper
066E  2104FF  	linein:	lxi	h,line	;get string of characters from console, ending in CR
0671  CD9800  	li0:	call	conin	;get a character
0674  FE08    		cpi	BS	;allow BackSpacing
0676          		jrz	backup
0676  281D    		DB	28H,backup-$-1
0678  FE0D    		cpi	CR
067A          		jrz	li1
067A  282E    		DB	28H,li1-$-1
067C  FE03    		cpi	CTLC
067E          		jrz	liZ
067E  2830    		DB	28H,liZ-$-1
0680  FE20    		cpi	' '	;ignore other non-print
0682          		jrc	li0
0682  38ED    		DB	38H,li0-$-1
0684  CD6506  		call	toupper
0687  77      		mov	m,a	;put character in line nuffer
0688  23      		inx	h
0689  4F      		mov	c,a
068A  CD8900  		call	conout	; echo character
068D  7D      		mov	a,l	;else check for pending buffer overflow
068E  D604    		sui	line mod 256
0690  FE40    		cpi	64
0692  C8      		rz		;stop if buffer full
0693          		jr	li0	;if not full, keep getting characters
0693  18DC    		DB	18H,li0-$-1
		
0695  7D      	backup:	mov	a,l	;(destructive) BackSpacing
0696  FE04    		cpi	line mod 256	;test if at beginning of line
0698          		jrz	li0	;can't backspace past start of line
0698  28D7    		DB	28H,li0-$-1
069A  0E08    		mvi	c,bs	;output BS," ",BS to erase character on screen
069C  CD8900  		call	conout	;and put cursor back one position
069F  CD3B06  		call	space
06A2  0E08    		mvi	c,bs
06A4  CD8900  		call	conout
06A7  2B      		dcx	h	;step buffer pointer back one
06A8          		jr	li0	;and continue to get characters
06A8  18C7    		DB	18H,li0-$-1
		
		; End line input, A=CR
06AA  77      	li1:	mov	m,a	; store CR in buffer
06AB  0E0D    		mvi	c,CR	;display CR so user knows we got it
06AD  C38900  		jmp	conout	;then return to calling routine
		
		; Abort input
06B0  0E5E    	liZ:	mvi	c,'^'
06B2  CD8900  		call	conout
06B5  0E43    		mvi	c,'C'
06B7  CD8900  		call	conout
06BA  E1      		pop	h	; always OK?
06BB  C9      		ret		; return to caller's caller (main debug loop)
		
		; Get next character from line buffer.
		; DE=current pointer within 'line'
		; Returns: ZR=EOL else A=char
06BC  7B      	char:	mov	a,e	;remove a character from line buffer,
06BD  D604    		sui	line mod 256	;testing for no more characters
06BF  D640    		sui	64
06C1  C8      		rz		;return [ZR] condition if at end of buffer
06C2  1A      		ldax	d
06C3  FE0D    		cpi	CR
06C5  C8      		rz		;also return [ZR] if at end of line
06C6  13      		inx	d	;else step to next character
06C7  C9      		ret		;and return [NZ]
		
		; Get HEX value from line buffer
		; Return: CY=error, HL=value, bit7(B)=1 if no input
06C8          	getaddr:		;extract address from line buffer (delimitted by " ")
06C8          		setb	7,b	;flag to detect no address entered
06C8  CBF8    		DB	0CBH,7*8+b+0C0H
06CA  210000  		lxi	h,0
06CD  CD0705  		call	skb
06D0  C8      		rz		;end of buffer/line before a character was found
06D1          		jr	ga1	;if not space, then start getting HEX digits
06D1  1804    		DB	18H,ga1-$-1
		
06D3  CDBC06  	ga0:	call	char
06D6  C8      		rz
06D7  CDEF06  	ga1:	call	hexcon	;start assembling digits into 16 bit accumilator
06DA          		jrc	chkdlm	;check if valid delimiter before returning error.
06DA  380E    		DB	38H,chkdlm-$-1
06DC          		res	7,b	;reset flag
06DC  CBB8    		DB	0CBH,7*8+b+80H
06DE  D5      		push	d	;save buffer pointer
06DF  5F      		mov	e,a
06E0  1600    		mvi	d,0
06E2  29      		dad	h	;shift "accumulator" left 1 digit
06E3  29      		dad	h
06E4  29      		dad	h
06E5  29      		dad	h
06E6  19      		dad	d	;add in new digit
06E7  D1      		pop	d	;restore buffer pointer
06E8          		jr	ga0	;loop for next digit
06E8  18E9    		DB	18H,ga0-$-1
		
06EA  FE20    	chkdlm: cpi	' '	;blank is currently the only valid delimiter
06EC  C8      		rz
06ED  37      		stc
06EE  C9      		ret
		
06EF          	hexcon: 		;convert ASCII character to HEX digit
06EF  FE30    		cpi	'0'	;must be .GE. "0"
06F1  D8      		rc
06F2  FE3A    		cpi	'9'+1	;and be .LE. "9"
06F4          		jrc	ok0	;valid numeral.
06F4  3809    		DB	38H,ok0-$-1
06F6  FE41    		cpi	'A'	;or .GE. "A"
06F8  D8      		rc
06F9  FE47    		cpi	'F'+1	;and .LE. "F"
06FB  3F      		cmc
06FC  D8      		rc		;return [CY] if not valid HEX digit
06FD  D607    		sui	'A'-'9'-1	;convert letter
06FF  D630    	ok0:	sui	'0'	;convert (numeral) to 0-15 in (A)
0701  C9      		ret
		
		; These only work on */84 (and 10) models.
		; Have no effect (and does nothing) on */83 models.
0702          	proginit:
0702  DB14    		in	sysp84
0704  E6FC    		ani	not DSNONE
0706  E6EF    		ani	not MTRON
0708  F602    		ori	DS0
070A  D314    		out	sysp84
070C  3E41    		mvi	a,'A'
070E  320030  		sta	3000h
0711  C9      		ret
		
0712          	progress:
0712  DB14    		in	sysp84
0714  EE03    		xri	DSNONE
0716  D314    		out	sysp84
0718  3A0030  		lda	3000h
071B  EE03    		xri	00000011b
071D  320030  		sta	3000h
0720  C9      		ret
		
			rept	0800h-$
0721  FF      		db	0ffh
0722  FF      		db	0ffh
0723  FF      		db	0ffh
0724  FF      		db	0ffh
0725  FF      		db	0ffh
0726  FF      		db	0ffh
0727  FF      		db	0ffh
0728  FF      		db	0ffh
0729  FF      		db	0ffh
072A  FF      		db	0ffh
072B  FF      		db	0ffh
072C  FF      		db	0ffh
072D  FF      		db	0ffh
072E  FF      		db	0ffh
072F  FF      		db	0ffh
0730  FF      		db	0ffh
0731  FF      		db	0ffh
0732  FF      		db	0ffh
0733  FF      		db	0ffh
0734  FF      		db	0ffh
0735  FF      		db	0ffh
0736  FF      		db	0ffh
0737  FF      		db	0ffh
0738  FF      		db	0ffh
0739  FF      		db	0ffh
073A  FF      		db	0ffh
073B  FF      		db	0ffh
073C  FF      		db	0ffh
073D  FF      		db	0ffh
073E  FF      		db	0ffh
073F  FF      		db	0ffh
0740  FF      		db	0ffh
0741  FF      		db	0ffh
0742  FF      		db	0ffh
0743  FF      		db	0ffh
0744  FF      		db	0ffh
0745  FF      		db	0ffh
0746  FF      		db	0ffh
0747  FF      		db	0ffh
0748  FF      		db	0ffh
0749  FF      		db	0ffh
074A  FF      		db	0ffh
074B  FF      		db	0ffh
074C  FF      		db	0ffh
074D  FF      		db	0ffh
074E  FF      		db	0ffh
074F  FF      		db	0ffh
0750  FF      		db	0ffh
0751  FF      		db	0ffh
0752  FF      		db	0ffh
0753  FF      		db	0ffh
0754  FF      		db	0ffh
0755  FF      		db	0ffh
0756  FF      		db	0ffh
0757  FF      		db	0ffh
0758  FF      		db	0ffh
0759  FF      		db	0ffh
075A  FF      		db	0ffh
075B  FF      		db	0ffh
075C  FF      		db	0ffh
075D  FF      		db	0ffh
075E  FF      		db	0ffh
075F  FF      		db	0ffh
0760  FF      		db	0ffh
0761  FF      		db	0ffh
0762  FF      		db	0ffh
0763  FF      		db	0ffh
0764  FF      		db	0ffh
0765  FF      		db	0ffh
0766  FF      		db	0ffh
0767  FF      		db	0ffh
0768  FF      		db	0ffh
0769  FF      		db	0ffh
076A  FF      		db	0ffh
076B  FF      		db	0ffh
076C  FF      		db	0ffh
076D  FF      		db	0ffh
076E  FF      		db	0ffh
076F  FF      		db	0ffh
0770  FF      		db	0ffh
0771  FF      		db	0ffh
0772  FF      		db	0ffh
0773  FF      		db	0ffh
0774  FF      		db	0ffh
0775  FF      		db	0ffh
0776  FF      		db	0ffh
0777  FF      		db	0ffh
0778  FF      		db	0ffh
0779  FF      		db	0ffh
077A  FF      		db	0ffh
077B  FF      		db	0ffh
077C  FF      		db	0ffh
077D  FF      		db	0ffh
077E  FF      		db	0ffh
077F  FF      		db	0ffh
0780  FF      		db	0ffh
0781  FF      		db	0ffh
0782  FF      		db	0ffh
0783  FF      		db	0ffh
0784  FF      		db	0ffh
0785  FF      		db	0ffh
0786  FF      		db	0ffh
0787  FF      		db	0ffh
0788  FF      		db	0ffh
0789  FF      		db	0ffh
078A  FF      		db	0ffh
078B  FF      		db	0ffh
078C  FF      		db	0ffh
078D  FF      		db	0ffh
078E  FF      		db	0ffh
078F  FF      		db	0ffh
0790  FF      		db	0ffh
0791  FF      		db	0ffh
0792  FF      		db	0ffh
0793  FF      		db	0ffh
0794  FF      		db	0ffh
0795  FF      		db	0ffh
0796  FF      		db	0ffh
0797  FF      		db	0ffh
0798  FF      		db	0ffh
0799  FF      		db	0ffh
079A  FF      		db	0ffh
079B  FF      		db	0ffh
079C  FF      		db	0ffh
079D  FF      		db	0ffh
079E  FF      		db	0ffh
079F  FF      		db	0ffh
07A0  FF      		db	0ffh
07A1  FF      		db	0ffh
07A2  FF      		db	0ffh
07A3  FF      		db	0ffh
07A4  FF      		db	0ffh
07A5  FF      		db	0ffh
07A6  FF      		db	0ffh
07A7  FF      		db	0ffh
07A8  FF      		db	0ffh
07A9  FF      		db	0ffh
07AA  FF      		db	0ffh
07AB  FF      		db	0ffh
07AC  FF      		db	0ffh
07AD  FF      		db	0ffh
07AE  FF      		db	0ffh
07AF  FF      		db	0ffh
07B0  FF      		db	0ffh
07B1  FF      		db	0ffh
07B2  FF      		db	0ffh
07B3  FF      		db	0ffh
07B4  FF      		db	0ffh
07B5  FF      		db	0ffh
07B6  FF      		db	0ffh
07B7  FF      		db	0ffh
07B8  FF      		db	0ffh
07B9  FF      		db	0ffh
07BA  FF      		db	0ffh
07BB  FF      		db	0ffh
07BC  FF      		db	0ffh
07BD  FF      		db	0ffh
07BE  FF      		db	0ffh
07BF  FF      		db	0ffh
07C0  FF      		db	0ffh
07C1  FF      		db	0ffh
07C2  FF      		db	0ffh
07C3  FF      		db	0ffh
07C4  FF      		db	0ffh
07C5  FF      		db	0ffh
07C6  FF      		db	0ffh
07C7  FF      		db	0ffh
07C8  FF      		db	0ffh
07C9  FF      		db	0ffh
07CA  FF      		db	0ffh
07CB  FF      		db	0ffh
07CC  FF      		db	0ffh
07CD  FF      		db	0ffh
07CE  FF      		db	0ffh
07CF  FF      		db	0ffh
07D0  FF      		db	0ffh
07D1  FF      		db	0ffh
07D2  FF      		db	0ffh
07D3  FF      		db	0ffh
07D4  FF      		db	0ffh
07D5  FF      		db	0ffh
07D6  FF      		db	0ffh
07D7  FF      		db	0ffh
07D8  FF      		db	0ffh
07D9  FF      		db	0ffh
07DA  FF      		db	0ffh
07DB  FF      		db	0ffh
07DC  FF      		db	0ffh
07DD  FF      		db	0ffh
07DE  FF      		db	0ffh
07DF  FF      		db	0ffh
07E0  FF      		db	0ffh
07E1  FF      		db	0ffh
07E2  FF      		db	0ffh
07E3  FF      		db	0ffh
07E4  FF      		db	0ffh
07E5  FF      		db	0ffh
07E6  FF      		db	0ffh
07E7  FF      		db	0ffh
07E8  FF      		db	0ffh
07E9  FF      		db	0ffh
07EA  FF      		db	0ffh
07EB  FF      		db	0ffh
07EC  FF      		db	0ffh
07ED  FF      		db	0ffh
07EE  FF      		db	0ffh
07EF  FF      		db	0ffh
07F0  FF      		db	0ffh
07F1  FF      		db	0ffh
07F2  FF      		db	0ffh
07F3  FF      		db	0ffh
07F4  FF      		db	0ffh
07F5  FF      		db	0ffh
07F6  FF      		db	0ffh
07F7  FF      		db	0ffh
07F8  FF      		db	0ffh
07F9  FF      		db	0ffh
07FA  FF      		db	0ffh
07FB  FF      		db	0ffh
07FC  FF      		db	0ffh
07FD  FF      		db	0ffh
07FE  FF      		db	0ffh
07FF  FF      		db	0ffh
		
		; RAM used...
FF00          		org	0ff00h
FF00          	addr0:	ds	2
FF02          	addr1:	ds	2
FF04          	line:	ds	64
		
FF44          		end



Statistics:

     4	passes
     0	jr promotions
   164	symbols
  2048	bytes

   448	macro calls
  3759	macro bytes
     0	invented symbols
