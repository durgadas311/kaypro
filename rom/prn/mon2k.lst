		; serial-port ROM monitor/boot for debugging Kaypro.
		; Uses "aux serial" a.k.a "Serial Printer" port.
		
0021          	VERN	equ	021h	; ROM version
		
FFFF          	rom2k	equ	-1
		
FFFF          	 if rom2k
0800          	romsiz	equ	0800h	; space for 2716 ROM
		 else
		 endif
		
			maclib	z80
**** z80.lib ****
**** mon2k.asm ****
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0003          	CTLC	equ	3
0007          	BEL	equ	7
0009          	TAB	equ	9
0008          	BS	equ	8
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
		; WD1943 at 5.0688MHz...
000E          	B9600	equ	0eh
0005          	B300	equ	05h
		; */84 (and 10) sysport drive select
0002          	DS0	equ	0010b
0001          	DS1	equ	0001b
0003          	DSNONE	equ	0011b	; also mask
0010          	K84MTR	equ	00010000b	; */84 (10) MOTOR control, 1=ON
0010          	K83PPS	equ	00010000b	; */83 ParPrt strobe (normally 0)
0040          	K84CCG	equ	01000000b	; */84 (10) CharGen A12
0040          	K83MTR	equ	01000000b	; */83 MOTOR control, 1=OFF
		
0004          	sio1	equ	04h	; "serial data", "keyboard"
000C          	sio2	equ	0ch	; "serial printer", "modem"
0000          	brd1	equ	00h
0008          	brd2	equ	08h
		
0000          	sioA	equ	00h	; offsets
0001          	sioB	equ	01h
		
0000          	sioD	equ	00h	; offsets
0002          	sioC	equ	02h
		
		; Choose Z80SIO port to use...
0004          	condat	equ	sio1+sioA+sioD
0006          	conctl	equ	sio1+sioA+sioC
0000          	conbrr	equ	brd1
		
0005          	kbddat	equ	sio1+sioB+sioD
0007          	kbdctl	equ	sio1+sioB+sioC
000C          	kbdbrr	equ	0ch	; */83 uses WD1943, else hardwired to 300 baud
		
001C          	crtctl	equ	1ch	; */84 and 10 only
001D          	crtdat	equ	1dh	; */84 and 10 only
001F          	crtram	equ	1fh	; also accesses CRTC
		
0014          	sysp84	equ	14h	; sysport on */84 (and 10). */83 have nothing here.
		
0010          	fpysts	equ	10h
0010          	fpycmd	equ	10h
0011          	fpytrk	equ	11h
0012          	fpysec	equ	12h
0013          	fpydat	equ	13h
		
0000          	stack	equ	00000h	; stack at top of memory (wrapped)
		
		; Start of ROM code
0000          		org	00000h
0008          	rst0e	equ	$+8
0000  C37000  		jmp	init
0003  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0010          	rst1e	equ	$+8
0008  C34B00  	rst1:	jmp	swtrap
000B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0018          	rst2e	equ	$+8
0010  C34B00  	rst2:	jmp	swtrap
0013  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0020          	rst3e	equ	$+8
0018  C34B00  	rst3:	jmp	swtrap
001B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0028          	rst4e	equ	$+8
0020  C34B00  	rst4:	jmp	swtrap
0023  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0030          	rst5e	equ	$+8
0028  C34B00  	rst5:	jmp	swtrap
002B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0038          	rst6e	equ	$+8
0030  C34B00  	rst6:	jmp	swtrap
0033  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0040          	rst7e	equ	$+8
0038  C34B00  	rst7:	jmp	swtrap
003B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
			; NMI not a problem?
		
0040  0D0A2A2A	swt:	db	CR,LF,'*** RST ',TRM
      2A205253
      542000
		
004B  F3      	swtrap:	di		; try to recover return address...
004C  D1      		pop	d	; should be caller of RST...
004D  310000  		lxi	sp,stack
0050  D5      		push	d	; not needed?
0051  214000  		lxi	h,swt
0054  CDA406  		call	msgprt
0057  D1      		pop	d
0058  CD7B06  		call	taddr
005B  CD9A06  		call	crlf
			; TODO: print address, etc...
005E  C3E500  		jmp	debug
		
			rept	0066h-$
0061  FF      		db	0ffh
0062  FF      		db	0ffh
0063  FF      		db	0ffh
0064  FF      		db	0ffh
0065  FF      		db	0ffh
0066  C9      	nmi:	ret
		
0067  18      	sioini:	db	18h	; reset
0068  0444    		db	4,044h	; 16x, 1s, Np
006A  03C1    		db	3,0c1h	; 8b, RxEn
006C  05EA    		db	5,0eah	; DTR, 8b, TxEn, RTS
006E  0100    		db	1,000h	;
0009          	siolen	equ	$-sioini
		
		; ROM start point - initialize everything
		; We know we have 64K RAM...
0070  F3      	init:	di
0071  310000  		lxi	sp,stack
		
			; init serial port
0074  3E0E    		mvi	a,B9600
0076  D300    		out	conbrr
0078  216700  		lxi	h,sioini
007B  0E06    		mvi	c,conctl
007D  0609    		mvi	b,siolen
007F          		outir
007F  EDB3    		DB	0EDH,0B3H
		
0081  21C500  		lxi	h,signon
0084  CDA406  		call	msgprt
		
0087  CD5C07  		call	proginit
			; save registers on stack, for debugger access...
008A  C3E500  		jmp	debug
		
008D          	belout:
008D  0E07    		mvi	c,BEL
		; Output char to console
		; C=char
008F          	conout:
008F  DB06    		in	conctl
0091  E604    		ani	00000100b
0093          		jrz	conout
0093  28FA    		DB	28H,conout-$-1
0095  79      		mov	a,c
0096  D304    		out	condat
0098  C9      		ret
		
0099  0D0A3A20	prompt:	db	CR,LF,': ',TRM
      00
		
		; Get char from console
		; Returns: A=char, stripped
009E  E5      	conin:	push	h
009F  210000  	ci2:	lxi	h,0
00A2  DB06    	ci0:	in	conctl		; 11
00A4  E601    		ani	00000001b	;  7
00A6          		jrnz	ci1		;  7
00A6  200A    		DB	20H,ci1-$-1
00A8  2B      		dcx	h		;  6
00A9  7D      		mov	a,l		;  4
00AA  B4      		ora	h		;  4
00AB          		jrnz	ci0		; 12 = 51 (12.75uS) (~0.8 sec)
00AB  20F5    		DB	20H,ci0-$-1
00AD  CD7007  		call	progress	; on */83 (20.4uS or ~1.3 sec)
00B0          		jr	ci2
00B0  18ED    		DB	18H,ci2-$-1
00B2  DB04    	ci1:	in	condat
00B4  E67F    		ani	07fh
00B6  E1      		pop	h
00B7  C9      		ret
		
		; Get char from console, toupper and echo
00B8          	conine:
00B8  CD9E00  		call	conin
00BB  CDBF06  		call	toupper
00BE  F5      		push	psw
00BF  4F      		mov	c,a
00C0  CD8F00  		call	conout
00C3  F1      		pop	psw
00C4  C9      		ret
		
00C5  0D0A4B61	signon:	db	CR,LF,'Kaypro'
      7970726F
FFFF          	 if rom2k
00CD  2D4949  		db	'-II'
		 endif
00D0  204D6F6E		db	' Monitor v'
      69746F72
      2076
00DA  322E31  	vernum:	db	(VERN SHR 4)+'0','.',(VERN AND 0fh)+'0'
00DD  0D0A00  		db	CR,LF,TRM
		
00E0  0D0A073F	errm:	db	CR,LF,BEL,'?',TRM
      00
		
		*********************************************************
		**  Debug mode
		*********************************************************
		
00E5          	debug:
00E5  310000  	cilp:	lxi	sp,stack
00E8  21E500  		lxi	h,cilp		;setup return address
00EB  E5      		push	h
00EC  219900  		lxi	h,prompt	;prompt for a command
00EF  CDA406  		call	msgprt
00F2  CDC806  		call	linein		;wait for command line to be entered
00F5  CD6507  		call	progoff		; turn off progress indicators
00F8  1104FF  		lxi	d,line
00FB  CD1607  		call	char		;get first character
00FE  C8      		rz			;ignore line if it is empty
00FF  211901  		lxi	h,comnds	;search table for command character
0102  060B    		mvi	b,ncmnds	;(number of commands)
0104  BE      	cci0:	cmp	m		;search command table
0105  23      		inx	h
0106          		jrz	gotocmd		;command was found, execute it
0106  280A    		DB	28H,gotocmd-$-1
0108  23      		inx	h		;step past routine address
0109  23      		inx	h
010A          		djnz	cci0		;loop untill all valid commands are checked
010A  10F8    		DB	10H,cci0-$-1
010C  21E000  	error:	lxi	h,errm		;if command unknown, beep and re-prompt
010F  C3A406  		jmp	msgprt
		
0112          	gotocmd:
0112  D5      		push	d		;save command line buffer pointer
0113  5E      		mov	e,m		;get command routine address
0114  23      		inx	h
0115  56      		mov	d,m		;DE = routine address
0116  EB      		xchg			;HL = routine address
0117  D1      		pop	d		;restore buffer pointer
0118  E9      		pchl			;jump to command routine
		
		; All commands are started with DE=next char in line buffer
0119          	comnds:
0119  3F      		db	'?'
011A  E402    		dw	Qcomnd
011C  44      		db	'D'
011D  8C03    		dw	Dcomnd
011F  53      		db	'S'
0120  F203    		dw	Scomnd
0122  47      		db	'G'
0123  5A04    		dw	Gcomnd
0125  4D      		db	'M'
0126  EB02    		dw	Mcomnd
0128  46      		db	'F'
0129  4C03    		dw	Fcomnd
012B  49      		db	'I'
012C  9504    		dw	Icomnd
012E  4F      		db	'O'
012F  E704    		dw	Ocomnd
0131  4E      		db	'N'
0132  1C05    		dw	Ncomnd
0134  54      		db	'T'
0135  6305    		dw	Tcomnd
0137  56      		db	'V'
0138  7506    		dw	Vcomnd
000B          	ncmnds	equ	($-comnds)/3
		
		*********************************************************
		**  Command subroutines
		*********************************************************
		
013A          	menu:
013A  0D0A4420		db	CR,LF,'D <start> <end> - display memory in HEX'
      3C737461
      72743E20
      3C656E64
      3E202D20
      64697370
      6C617920
      6D656D6F
      72792069
      6E204845
      58
0163  0D0A5320		db	CR,LF,'S <start> - set/view memory'
      3C737461
      72743E20
      2D207365
      742F7669
      6577206D
      656D6F72
      79
0180  0D0A2020		db	CR,LF,'    (CR) = skip fwd, ''-'' = skip bkwd, ''.'' = done'
      20202843
      5229203D
      20736B69
      70206677
      642C2027
      2D27203D
      20736B69
      7020626B
      77642C20
      272E2720
      3D20646F
      6E65
01B2  0D0A4720		db	CR,LF,'G <start> - go to address'
      3C737461
      72743E20
      2D20676F
      20746F20
      61646472
      657373
01CD  0D0A4620		db	CR,LF,'F <start> <end> <data> - fill memory'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6174613E
      202D2066
      696C6C20
      6D656D6F
      7279
01F3  0D0A4D20		db	CR,LF,'M <start> <end> <dest> - Move data'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6573743E
      202D204D
      6F766520
      64617461
0217  0D0A4920		db	CR,LF,'I <port> [num] - Input from port'
      3C706F72
      743E205B
      6E756D5D
      202D2049
      6E707574
      2066726F
      6D20706F
      7274
0239  0D0A4F20		db	CR,LF,'O <port> <value> [...] - Output to port'
      3C706F72
      743E203C
      76616C75
      653E205B
      2E2E2E5D
      202D204F
      75747075
      7420746F
      20706F72
      74
0262  0D0A4E20		db	CR,LF,'N <hw> - iNitialize hardware (KB83'
      3C68773E
      202D2069
      4E697469
      616C697A
      65206861
      72647761
      72652028
      4B423833
0000          	 if not rom2k
		 endif
0286  29      		db		')'
0287  0D0A5420		db	CR,LF,'T <hw> - Test hardware'
      3C68773E
      202D2054
      65737420
      68617264
      77617265
029F  0D0A2020		db	CR,LF,'  (KBD'
      284B4244
0000          	 if not rom2k
		 endif
02A7  2C204644		db		', FDRD, FLPY)'
      52442C20
      464C5059
      29
02B4  0D0A5620		db	CR,LF,'V - Show ROM version'
      2D205368
      6F772052
      4F4D2076
      65727369
      6F6E
02CA  0D0A5E43		db	CR,LF,'^C aborts command entry'
      2061626F
      72747320
      636F6D6D
      616E6420
      656E7472
      79
02E3  00      		db	TRM
		
02E4          	Qcomnd:
02E4  213A01  		lxi	h,menu
02E7  CDA406  		call	msgprt
02EA  C9      		ret
		
02EB  CD2207  	Mcomnd:	call	getaddr
02EE  DA0C01  		jc	error
02F1          		bit	7,b
02F1  CB78    		DB	0CBH,7*8+b+40H
02F3  C20C01  		jnz	error
02F6  2200FF  		shld	addr0
02F9  CD2207  		call	getaddr
02FC  DA0C01  		jc	error
02FF          		bit	7,b
02FF  CB78    		DB	0CBH,7*8+b+40H
0301  C20C01  		jnz	error
0304  2202FF  		shld	addr1
0307  CD2207  		call	getaddr
030A  DA0C01  		jc	error
030D          		bit	7,b
030D  CB78    		DB	0CBH,7*8+b+40H
030F  C20C01  		jnz	error
0312  EB      		xchg
0313          		lbcd	addr0
0313  ED4B    		DB	0EDH,4BH
0315  00FF    		DW	addr0
0317  2A02FF  		lhld	addr1
031A  B7      		ora	a
031B          		dsbc	b
031B  ED42    		DB	0EDH,b*8+42H
031D  DA0C01  		jc	error
0320  23      		inx	h
0321  4D      		mov	c,l
0322  44      		mov	b,h
0323  D5      		push	d
0324  EB      		xchg
0325  09      		dad	b
0326  D1      		pop	d
0327  DA0C01  		jc	error
032A  2A02FF  		lhld	addr1
032D  CDB906  		call	check
0330  DA4603  		jc	mc0
0333  2A00FF  		lhld	addr0
0336  CDB906  		call	check
0339  D24603  		jnc	mc0
033C  2A02FF  		lhld	addr1
033F  EB      		xchg
0340  09      		dad	b
0341  2B      		dcx	h
0342  EB      		xchg
0343          		lddr
0343  EDB8    		DB	0EDH,0B8H
0345  C9      		ret
0346  2A00FF  	mc0:	lhld	addr0
0349          		ldir
0349  EDB0    		DB	0EDH,0B0H
034B  C9      		ret
034C          	Fcomnd:
034C  CD2207  		call	getaddr ;get address to start at
034F  DA0C01  		jc	error	;error if non-hex character
0352          		bit	7,b	;test for no address (different from 0000)
0352  CB78    		DB	0CBH,7*8+b+40H
0354  C20C01  		jnz	error	;error if no address was entered
0357  2200FF  		shld	addr0	;save starting address
035A  CD2207  		call	getaddr ;get stop address
035D  DA0C01  		jc	error	;error if non-hex character
0360          		bit	7,b	;test for no entry
0360  CB78    		DB	0CBH,7*8+b+40H
0362  C20C01  		jnz	error	;error if no stop address
0365  2202FF  		shld	addr1	;save stop address
0368  CD2207  		call	getaddr ;get fill data
036B  DA0C01  		jc	error	;error if non-hex character
036E          		bit	7,b	;test for no entry
036E  CB78    		DB	0CBH,7*8+b+40H
0370  C20C01  		jnz	error	;error if no fill data
0373  7C      		mov	a,h
0374  B7      		ora	a
0375  C20C01  		jnz	error
0378  4D      		mov	c,l	;(C)=fill data
0379  2A02FF  		lhld	addr1	;get stop address
037C          		lded	addr0	;get start address
037C  ED5B    		DB	0EDH,5BH
037E  00FF    		DW	addr0
0380  79      	fc0:	mov	a,c	;
0381  12      		stax	d	;put byte in memory
0382  13      		inx	d	;step to next byte
0383  7A      		mov	a,d	;
0384  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
0385  C8      		rz		;
0386  CDB906  		call	check	;test for past stop address
0389  D8      		rc	;quit if past stop address
038A          		jr	fc0
038A  18F4    		DB	18H,fc0-$-1
		
038C          	Dcomnd:		;display memory
038C  CD2207  		call	getaddr ;get address to start at
038F  DA0C01  		jc	error	;error if non-hex character
0392          		bit	7,b	;test for no address (different from 0000)
0392  CB78    		DB	0CBH,7*8+b+40H
0394  C20C01  		jnz	error	;error if no address was entered
0397  2200FF  		shld	addr0	;save starting address
039A  CD2207  		call	getaddr ;get stop address
039D  DA0C01  		jc	error	;error if non-hex character
03A0          		bit	7,b	;test for no entry
03A0  CB78    		DB	0CBH,7*8+b+40H
03A2  C20C01  		jnz	error	;error if no stop address
03A5          		lded	addr0	;get start address into (DE)
03A5  ED5B    		DB	0EDH,5BH
03A7  00FF    		DW	addr0
03A9  CD9A06  	dis0:	call	crlf	;start on new line
03AC  CD7B06  		call	taddr	;print current address
03AF  CD9506  		call	space	;delimit it from data
03B2  0610    		mvi	b,16	;display 16 bytes on each line
03B4  1A      	dis1:	ldax	d	;get byte to display
03B5  13      		inx	d	;step to next byte
03B6  CD8006  		call	hexout	;display this byte in HEX
03B9  CD9506  		call	space	;delimit it from others
03BC  7A      		mov	a,d
03BD  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03BE          		jrz	dis2
03BE  2807    		DB	28H,dis2-$-1
03C0  CDB906  		call	check	;test for past stop address
03C3          		jrc	dis2	;quit if past stop address
03C3  3802    		DB	38H,dis2-$-1
03C5          		djnz	dis1	;else do next byte on this line
03C5  10ED    		DB	10H,dis1-$-1
03C7  CD9506  	dis2:	call	space	;delimit it from data
03CA  CD9506  		call	space
03CD          		lded	addr0
03CD  ED5B    		DB	0EDH,5BH
03CF  00FF    		DW	addr0
03D1  0610    		mvi	b,16	;display 16 bytes on each line
03D3  1A      	dis3:	ldax	d	;get byte to display
03D4  13      		inx	d	;step to next byte
03D5  0E2E    		mvi	c,'.'
03D7  FE20    		cpi	' '
03D9          		jrc	dis4
03D9  3805    		DB	38H,dis4-$-1
03DB  FE7F    		cpi	'~'+1
03DD          		jrnc	dis4
03DD  3001    		DB	30H,dis4-$-1
03DF  4F      		mov	c,a
03E0  CD8F00  	dis4:	call	conout
03E3  7A      		mov	a,d
03E4  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03E5  C8      		rz
03E6  CDB906  		call	check	;test for past stop address
03E9  D8      		rc	;quit if past stop address
03EA          		djnz	dis3	;else do next byte on this line
03EA  10E7    		DB	10H,dis3-$-1
03EC          		sded	addr0
03EC  ED53    		DB	0EDH,53H
03EE  00FF    		DW	addr0
03F0          		jr	dis0	;when line is finished, start another
03F0  18B7    		DB	18H,dis0-$-1
		
03F2          	Scomnd: 		;substitute (set) memory
03F2  CD2207  		call	getaddr ;get address to start substitution at
03F5  DA0C01  		jc	error	;error if non-hex character
03F8          		bit	7,b	;test for no entry
03F8  CB78    		DB	0CBH,7*8+b+40H
03FA  C20C01  		jnz	error	;error if no address
03FD  EB      		xchg		;put address in (DE)
03FE  CD9A06  	sb1:	call	crlf	;start on new line
0401  CD7B06  		call	taddr	;print address
0404  CD9506  		call	space	;and delimit it
0407  1A      		ldax	d	;get current value of byte
0408  CD8006  		call	hexout	;and display it
040B  CD9506  		call	space	;delimit it from user's (posible) entry
040E  0600    		mvi	b,0	;zero accumilator for user's entry
0410  CDB800  	sb2:	call	conine	;get user's first character
0413  FE0D    		cpi	CR	;if CR then skip to next byte
0415          		jrz	foward
0415  2833    		DB	28H,foward-$-1
0417  FE20    		cpi	' '	;or if Space then skip to next
0419          		jrz	foward
0419  282F    		DB	28H,foward-$-1
041B  FE2D    		cpi	'-'	;if Minus then step back to previous address
041D          		jrz	bakwrd
041D  282E    		DB	28H,bakwrd-$-1
041F  FE2E    		cpi	'.'	;if Period then stop substitution
0421  C8      		rz
0422  CD4907  		call	hexcon	;if none of the above, should be HEX digit
0425          		jrc	error0	;error if not
0425  3829    		DB	38H,error0-$-1
0427          		jr	sb3	;start accumilating HEX digits
0427  1805    		DB	18H,sb3-$-1
0429  CD4907  	sb0:	call	hexcon	;test for HEX digit
042C          		jrc	error1	;error if not HEX
042C  3827    		DB	38H,error1-$-1
042E          	sb3:	slar	b	;roll accumilator to receive new digit
042E  CB20    		DB	0CBH, 20H + b
0430          		slar	b
0430  CB20    		DB	0CBH, 20H + b
0432          		slar	b
0432  CB20    		DB	0CBH, 20H + b
0434          		slar	b
0434  CB20    		DB	0CBH, 20H + b
0436  B0      		ora	b	;merge in new digit
0437  47      		mov	b,a
0438  CDB800  	sb4:	call	conine	;get next character
043B  FE0D    		cpi	CR	;if CR then put existing byte into memory
043D          		jrz	putbyte ;  and step to next.
043D  2809    		DB	28H,putbyte-$-1
043F  FE2E    		cpi	'.'
0441  C8      		rz
0442  FE7F    		cpi	del	;if DEL then restart at same address
0444          		jrz	sb1
0444  28B8    		DB	28H,sb1-$-1
0446          		jr	sb0	;else continue entering hex digits
0446  18E1    		DB	18H,sb0-$-1
0448          	putbyte:
0448  78      		mov	a,b	;store accumilated byte in memory
0449  12      		stax	d
044A          	foward:
044A  13      		inx	d	;step to next location
044B          		jr	sb1	;and allow substitution there
044B  18B1    		DB	18H,sb1-$-1
		
044D          	bakwrd:
044D  1B      		dcx	d	;move address backward one location
044E          		jr	sb1
044E  18AE    		DB	18H,sb1-$-1
		
0450  CD8D00  	error0:	call	belout	;user's entry was not valid, beep and continue
0453          		jr	sb2
0453  18BB    		DB	18H,sb2-$-1
0455  CD8D00  	error1:	call	belout	;same as above but for different section of routine
0458          		jr	sb4
0458  18DE    		DB	18H,sb4-$-1
		
045A          	Gcomnd: 		;jump to address given by user
045A  CD2207  		call	getaddr ;get address to jump to
045D  DA0C01  		jc	error	;error if non-hex character
0460          		bit	7,b	;test for no entry
0460  CB78    		DB	0CBH,7*8+b+40H
0462  C20C01  		jnz	error	;error if no address entered
0465  CD9A06  		call	crlf	;on new line,
0468  0E47    		mvi	c,'G'	;display "GO aaaa?" to ask
046A  CD8F00  		call	conout	;user to verify that we should
046D  0E4F    		mvi	c,'O'	;jump to this address (in case user
046F  CD8F00  		call	conout	;made a mistake we should not blindly
0472  CD9506  		call	space	;commit suicide)
0475  EB      		xchg
0476  CD7B06  		call	taddr
0479  CD9506  		call	space
047C  0E3F    		mvi	c,'?'
047E  CD8F00  		call	conout
0481  CDB800  		call	conine	;wait for user to type "Y" to
0484  FE59    		cpi	'Y'	;indicate that we should jump.
0486  C0      		rnz		;abort if response was not "Y"
0487  CD9A06  		call	crlf	; visual feedback
048A  EB      		xchg
048B  E9      		pchl		;else jump to address
		
048C  0D0A496E	inpms:	db	CR,LF,'Input ',TRM
      70757420
      00
0495          	Icomnd:
0495  CD2207  		call	getaddr ;get port address, ignore extra MSDs
0498  DA0C01  		jc	error	;error if non-hex character
049B          		bit	7,b	;test for no entry
049B  CB78    		DB	0CBH,7*8+b+40H
049D  C20C01  		jnz	error	;error if no address entered
04A0  E5      		push	h	; save port
04A1  CD2207  		call	getaddr	; hex number of inputs to do
04A4  DA0C01  		jc	error
04A7          		bit	7,b
04A7  CB78    		DB	0CBH,7*8+b+40H
04A9          		jrz	ic0
04A9  2803    		DB	28H,ic0-$-1
04AB  210100  		lxi	h,1
04AE          	ic0:
04AE  E3      		xthl		; save count
04AF  E5      		push	h	; re-save port
04B0  218C04  		lxi	h,inpms
04B3  CDA406  		call	msgprt
04B6  E1      		pop	h
04B7  E5      		push	h
04B8  7D      		mov	a,l
04B9  CD8006  		call	hexout
04BC  CD9506  		call	space
04BF  0E3D    		mvi	c,'='
04C1  CD8F00  		call	conout
			; "Input XX ="
04C4  C1      		pop	b	; port to BC
04C5  E1      		pop	h	; count to HL (L)
04C6  260D    		mvi	h,16-3
04C8  0600    		mvi	b,0	; safety
04CA  C5      		push	b	; C gets trashed by conout
04CB          	ic1:
04CB  CD9506  		call	space
04CE  C1      		pop	b
04CF  C5      		push	b
04D0          		inp	a
04D0  ED78    		DB	0EDH,a*8+40H
04D2  CD8006  		call	hexout
04D5  2D      		dcr	l	; assume <= 256
04D6          		jrz	ic2
04D6  280A    		DB	28H,ic2-$-1
04D8  25      		dcr	h	; col count
04D9          		jrnz	ic1
04D9  20F0    		DB	20H,ic1-$-1
04DB  CD9A06  		call	crlf
04DE  2610    		mvi	h,16
04E0          		jr	ic1
04E0  18E9    		DB	18H,ic1-$-1
04E2          	ic2:
04E2  C1      		pop	b	; fix stack
04E3  CD9A06  		call	crlf
04E6  C9      		ret
		
		; TODO: no feedback?
04E7          	Ocomnd:
04E7  CD2207  		call	getaddr ;get port address, ignore extra MSDs
04EA  DA0C01  		jc	error	;error if non-hex character
04ED          		bit	7,b	;test for no entry
04ED  CB78    		DB	0CBH,7*8+b+40H
04EF  C20C01  		jnz	error	;error if no address entered
04F2  2600    		mvi	h,0	; safety
04F4  E5      		push	h	; save port
04F5  CD2207  		call	getaddr ;get value, ignore extra MSDs
04F8  DA0C01  		jc	error	;error if non-hex character
04FB          		bit	7,b	;test for no entry
04FB  CB78    		DB	0CBH,7*8+b+40H
04FD  C20C01  		jnz	error	;error if no value entered
0500  CD9A06  		call	crlf
0503          	oc0:		; L has byte to output...
0503  C1      		pop	b	; port
0504  C5      		push	b
0505          		outp	l
0505  ED69    		DB	0EDH,l*8+41H
0507  CD2207  		call	getaddr ;get value, ignore extra MSDs
050A  DA0C01  		jc	error	;error if non-hex character
					;NOTE: some output has been sent
050D          		bit	7,b	;test for no entry
050D  CB78    		DB	0CBH,7*8+b+40H
050F          		jrz	oc0	;still more to send
050F  28F2    		DB	28H,oc0-$-1
0511  E1      		pop	h	; discard port
0512  C9      		ret
		
0513  CD1607  	skb:	call	char
0516  C8      		rz		;end of buffer/line before a character was found (ZR)
0517  FE20    		cpi	' '	;skip all leading spaces
0519  C0      		rnz		;if not space, then done (NZ)
051A          		jr	skb	;else if space, loop untill not space
051A  18F7    		DB	18H,skb-$-1
		
051C          	Ncomnd:
051C  CD1305  		call	skb	; skip blanks
051F  CA0C01  		jz	error	; required param
			; this may need refinement
0522  1B      		dcx	d
0523  212E05  		lxi	h,kb83
0526  CD4F05  		call	strcmp
0529          		jrz	nkb83
0529  2816    		DB	28H,nkb83-$-1
0000          	 if not rom2k
		 endif
052B  C30C01  		jmp	error
		
052E  4B423833	kb83:	db	'KB83',TRM
      00
0000          	 if not rom2k
		 endif
0533  46445244	fdrd:	db	'FDRD',TRM
      00
0538  464C5059	flpy:	db	'FLPY',TRM
      00
053D  4B424400	kbd:	db	'KBD',TRM
		
0541  3E05    	nkb83:	mvi	a,B300
0543  D30C    		out	kbdbrr	; */83 baud gen for SIO1 ch B
0545  216700  	nkb84:	lxi	h,sioini
0548  0E07    		mvi	c,kbdctl
054A  0609    		mvi	b,siolen
054C          		outir
054C  EDB3    		DB	0EDH,0B3H
054E  C9      		ret
		
0000          	 if not rom2k
		 endif
		
		; if match, return DE after last match.
		; if no match, return original DE.
054F  D5      	strcmp:	push	d
0550  AF      		xra	a
0551  BE      	sc0:	cmp	m	; TRM?
0552          		jrz	sc9	; A = 0
0552  2808    		DB	28H,sc9-$-1
0554  1A      		ldax	d
0555  96      		sub	m
0556          		jrnz	sc8	; A is NZ
0556  2008    		DB	20H,sc8-$-1
0558  23      		inx	h
0559  13      		inx	d
055A          		jr	sc0
055A  18F5    		DB	18H,sc0-$-1
055C  33      	sc9:	inx	sp	; non-destructive POP
055D  33      		inx	sp
055E  AF      		xra	a	; A=0 and ZR
055F  C9      		ret
0560  D1      	sc8:	pop	d	; restore orig location
0561  B7      		ora	a
0562  C9      		ret
		
0563          	Tcomnd:
0563  CD1305  		call	skb	; skip blanks
0566  CA0C01  		jz	error	; required param
			; this may need refinement
0569  1B      		dcx	d
056A  213D05  		lxi	h,kbd
056D  CD4F05  		call	strcmp
0570          		jrz	tkbd
0570  2815    		DB	28H,tkbd-$-1
0000          	 if not rom2k
		 endif
0572  213305  		lxi	h,fdrd
0575  CD4F05  		call	strcmp
0578  CABD05  		jz	tfdrd
057B  213805  		lxi	h,flpy
057E  CD4F05  		call	strcmp
0581  CAF605  		jz	tflpy
0584  C30C01  		jmp	error
		
0000          	 if not rom2k
		 endif
		
0587  21AC05  	tkbd:	lxi	h,waitm
058A  CDA406  		call	msgprt
058D  DB07    	tk0:	in	kbdctl
058F  E601    		ani	00000001b
0591          		jrnz	tk1
0591  200F    		DB	20H,tk1-$-1
0593  DB06    		in	conctl
0595  E601    		ani	00000001b
0597          		jrz	tk0
0597  28F4    		DB	28H,tk0-$-1
0599  DB04    		in	condat
059B  21B705  		lxi	h,abrtm
059E  CDA406  		call	msgprt
05A1  C9      		ret
05A2  DB05    	tk1:	in	kbddat
05A4  CD8006  		call	hexout
05A7  CD9506  		call	space
05AA          		jr	tk0
05AA  18E1    		DB	18H,tk0-$-1
		
05AC  0D0A5761	waitm:	db	CR,LF,'Wait... ',TRM
      69742E2E
      2E2000
05B7  41626F72	abrtm:	db	'Abort',TRM
      7400
0000          	 if not rom2k
		 endif
		
		; read a sector from the floppy.
		; user must turn on motors, select drive,
		; set side, set DDEN, and step to track.
		; data stored in 8000h
05BD  AF      	tfdrd:	xra	a
05BE  3200FF  		sta	addr0
05C1  CD2207  		call	getaddr ;get optional sector
05C4  DA0C01  		jc	error	;error if non-hex character
05C7          		bit	7,b	;test for no entry
05C7  CB78    		DB	0CBH,7*8+b+40H
05C9          		jrnz	tfrX
05C9  2008    		DB	20H,tfrX-$-1
05CB  7C      		mov	a,h
05CC  B7      		ora	a
05CD  C20C01  		jnz	error
05D0  2200FF  		shld	addr0	; allow some rediculous values
05D3          	tfrX:			; (also, side 1 uses: 0A..13)
05D3  CD9A06  		call	crlf
05D6  3A00FF  		lda	addr0
05D9  D312    		out	fpysec
05DB  210080  		lxi	h,8000h
05DE  011300  		lxi	b,fpydat	; B=0
05E1  3E88    		mvi	a,88h	; read sector, side compare(?)
05E3  D310    		out	fpycmd
05E5  76      	tfr0:	hlt
05E6          		ini
05E6  EDA2    		DB	0EDH,0A2H
05E8          		jrnz	tfr0
05E8  20FB    		DB	20H,tfr0-$-1
05EA  76      	tfr1:	hlt
05EB          		ini
05EB  EDA2    		DB	0EDH,0A2H
05ED          		jrnz	tfr1
05ED  20FB    		DB	20H,tfr1-$-1
05EF  76      		hlt	; wait for done
05F0  DB10    		in	fpysts
05F2  CD8006  		call	hexout
05F5  C9      		ret
		
05F6          	tflpy:	; user must motor on and select drive (and side)
05F6  3ED0    		mvi	a,0d0h
05F8  3200FF  		sta	addr0	; default: force intr
05FB  AF      		xra	a
05FC  3202FF  		sta	addr1	; default: 256 samples
			; TODO: parse optional args
05FF  CD2207  		call	getaddr ;get optional command
0602  DA0C01  		jc	error	;error if non-hex character
0605          		bit	7,b	;test for no entry
0605  CB78    		DB	0CBH,7*8+b+40H
0607          		jrnz	tfX
0607  201B    		DB	20H,tfX-$-1
0609  7C      		mov	a,h
060A  B7      		ora	a
060B  C20C01  		jnz	error
060E  2200FF  		shld	addr0	;save command
0611  CD2207  		call	getaddr ;get fill data
0614  DA0C01  		jc	error	;error if non-hex character
0617          		bit	7,b	;test for no entry
0617  CB78    		DB	0CBH,7*8+b+40H
0619  C22406  		jnz	tfX
061C  7C      		mov	a,h
061D  B7      		ora	a
061E  C20C01  		jnz	error
0621  2202FF  		shld	addr1	;save count
0624          	tfX:
0624  CD9A06  		call	crlf
0627  DB10    		in	fpysts
0629  4F      		mov	c,a
062A  3A00FF  		lda	addr0	; FDC command
062D  D310    		out	fpycmd
062F  210000  		lxi	h,0
0632  110080  		lxi	d,8000h
		
0635  DB10    	tf0:	in	fpysts	; 11
0637  B9      		cmp	c	;  4
0638          		jrnz	tf4	;  7
0638  2027    		DB	20H,tf4-$-1
063A  23      	tf5:	inx	h	;  6
063B  7C      		mov	a,h	;  4
063C  B5      		ora	l	;  4
063D          		jrnz	tf0	; 12 = 48 = 12uS
063D  20F6    		DB	20H,tf0-$-1
063F          	tf1:	; dump 8000h..DE
063F  210080  		lxi	h,8000h
0642          	tf2:
0642  7C      		mov	a,h
0643  BA      		cmp	d
0644          		jrnz	tf3
0644  2003    		DB	20H,tf3-$-1
0646  7D      		mov	a,l
0647  BB      		cmp	e
0648  C8      		rz	; user must motor off...
0649          	tf3:
0649  7E      		mov	a,m
064A  23      		inx	h
064B  CD8006  		call	hexout
064E  CD9506  		call	space
0651  46      		mov	b,m
0652  23      		inx	h
0653  7E      		mov	a,m
0654  23      		inx	h
0655  CD8006  		call	hexout
0658  78      		mov	a,b
0659  CD8006  		call	hexout
065C  CD9A06  		call	crlf
065F          		jr	tf2
065F  18E1    		DB	18H,tf2-$-1
		
		; save sample, check for done.
0661  EB      	tf4:	xchg
0662  77      		mov	m,a
0663  23      		inx	h
0664  73      		mov	m,e
0665  23      		inx	h
0666  72      		mov	m,d
0667  23      		inx	h
0668  EB      		xchg
0669  4F      		mov	c,a
066A  3A02FF  		lda	addr1
066D  3D      		dcr	a
066E  3202FF  		sta	addr1
0671          		jrz	tf1
0671  28CC    		DB	28H,tf1-$-1
0673          		jr	tf5
0673  18C5    		DB	18H,tf5-$-1
		
0675          	Vcomnd:
0675  21C500  		lxi	h,signon
0678  C3A406  		jmp	msgprt
		
		*********************************************************
		**  Utility subroutines
		*********************************************************
		
067B  7A      	taddr:	mov	a,d	;display (DE) at console in HEX
067C  CD8006  		call	hexout	;print HI byte in HEX
067F  7B      		mov	a,e	;now do LO byte
0680  F5      	hexout:	push	psw	;output (A) to console in HEX
0681  07      		rlc		;get HI digit in usable (LO) position
0682  07      		rlc
0683  07      		rlc
0684  07      		rlc
0685  CD8906  		call	nible	;and display it
0688  F1      		pop	psw	;get LO digit back and display it
0689  E60F    	nible:	ani	00001111b	;display LO 4 bits of (A) in HEX
068B  C690    		adi	90h	;algorithm to convert 4-bits to ASCII
068D  27      		daa
068E  CE40    		aci	40h
0690  27      		daa
0691  4F      		mov	c,a	;display ASCII digit
0692  C38F00  		jmp	conout
		
0695  0E20    	space:	mvi	c,' '	;send an ASCII blank to console
0697  C38F00  		jmp	conout
		
069A  0E0D    	crlf:	mvi	c,CR	;send Carriage-Return/Line-Feed to console
069C  CD8F00  		call	conout
069F  0E0A    		mvi	c,LF
06A1  C38F00  		jmp	conout
		
06A4  7E      	msgprt:	mov	a,m	;send string to console, terminated by 00
06A5  B7      		ora	a
06A6  C8      		rz
06A7  4F      		mov	c,a
06A8  CD8F00  		call	conout
06AB  23      		inx	h
06AC          		jr	msgprt
06AC  18F6    		DB	18H,msgprt-$-1
		
06AE  7E      	print:	mov	a,m	; BDOS func 9 style msgprt
06AF  FE24    		cpi	'$'
06B1  C8      		rz
06B2  4F      		mov	c,a
06B3  CD8F00  		call	conout
06B6  23      		inx	h
06B7          		jr	print
06B7  18F5    		DB	18H,print-$-1
		
06B9  E5      	check:	push	h	;non-destuctive compare HL:DE
06BA  B7      		ora	a
06BB          		dsbc	d
06BB  ED52    		DB	0EDH,d*8+42H
06BD  E1      		pop	h
06BE  C9      		ret
		
		; Convert letters to upper-case
06BF          	toupper:
06BF  FE61    		cpi	'a'
06C1  D8      		rc
06C2  FE7B    		cpi	'z'+1
06C4  D0      		rnc
06C5  E65F    		ani	01011111b
06C7  C9      		ret
		
		; Read a line of text into 'line'
		; End with CR, honor BS
		; Reject all non-printing characters, force toupper
06C8  2104FF  	linein:	lxi	h,line	;get string of characters from console, ending in CR
06CB  CD9E00  	li0:	call	conin	;get a character
06CE  FE08    		cpi	BS	;allow BackSpacing
06D0          		jrz	backup
06D0  281D    		DB	28H,backup-$-1
06D2  FE0D    		cpi	CR
06D4          		jrz	li1
06D4  282E    		DB	28H,li1-$-1
06D6  FE03    		cpi	CTLC
06D8          		jrz	liZ
06D8  2830    		DB	28H,liZ-$-1
06DA  FE20    		cpi	' '	;ignore other non-print
06DC          		jrc	li0
06DC  38ED    		DB	38H,li0-$-1
06DE  CDBF06  		call	toupper
06E1  77      		mov	m,a	;put character in line nuffer
06E2  23      		inx	h
06E3  4F      		mov	c,a
06E4  CD8F00  		call	conout	; echo character
06E7  7D      		mov	a,l	;else check for pending buffer overflow
06E8  D604    		sui	line mod 256
06EA  FE40    		cpi	64
06EC  C8      		rz		;stop if buffer full
06ED          		jr	li0	;if not full, keep getting characters
06ED  18DC    		DB	18H,li0-$-1
		
06EF  7D      	backup:	mov	a,l	;(destructive) BackSpacing
06F0  FE04    		cpi	line mod 256	;test if at beginning of line
06F2          		jrz	li0	;can't backspace past start of line
06F2  28D7    		DB	28H,li0-$-1
06F4  0E08    		mvi	c,bs	;output BS," ",BS to erase character on screen
06F6  CD8F00  		call	conout	;and put cursor back one position
06F9  CD9506  		call	space
06FC  0E08    		mvi	c,bs
06FE  CD8F00  		call	conout
0701  2B      		dcx	h	;step buffer pointer back one
0702          		jr	li0	;and continue to get characters
0702  18C7    		DB	18H,li0-$-1
		
		; End line input, A=CR
0704  77      	li1:	mov	m,a	; store CR in buffer
0705  0E0D    		mvi	c,CR	;display CR so user knows we got it
0707  C38F00  		jmp	conout	;then return to calling routine
		
		; Abort input
070A  0E5E    	liZ:	mvi	c,'^'
070C  CD8F00  		call	conout
070F  0E43    		mvi	c,'C'
0711  CD8F00  		call	conout
0714  E1      		pop	h	; always OK?
0715  C9      		ret		; return to caller's caller (main debug loop)
		
		; Get next character from line buffer.
		; DE=current pointer within 'line'
		; Returns: ZR=EOL else A=char
0716  7B      	char:	mov	a,e	;remove a character from line buffer,
0717  D604    		sui	line mod 256	;testing for no more characters
0719  D640    		sui	64
071B  C8      		rz		;return [ZR] condition if at end of buffer
071C  1A      		ldax	d
071D  FE0D    		cpi	CR
071F  C8      		rz		;also return [ZR] if at end of line
0720  13      		inx	d	;else step to next character
0721  C9      		ret		;and return [NZ]
		
		; Get HEX value from line buffer
		; Return: CY=error, HL=value, bit7(B)=1 if no input
0722          	getaddr:		;extract address from line buffer (delimitted by " ")
0722          		setb	7,b	;flag to detect no address entered
0722  CBF8    		DB	0CBH,7*8+b+0C0H
0724  210000  		lxi	h,0
0727  CD1305  		call	skb
072A  C8      		rz		;end of buffer/line before a character was found
072B          		jr	ga1	;if not space, then start getting HEX digits
072B  1804    		DB	18H,ga1-$-1
		
072D  CD1607  	ga0:	call	char
0730  C8      		rz
0731  CD4907  	ga1:	call	hexcon	;start assembling digits into 16 bit accumilator
0734          		jrc	chkdlm	;check if valid delimiter before returning error.
0734  380E    		DB	38H,chkdlm-$-1
0736          		res	7,b	;reset flag
0736  CBB8    		DB	0CBH,7*8+b+80H
0738  D5      		push	d	;save buffer pointer
0739  5F      		mov	e,a
073A  1600    		mvi	d,0
073C  29      		dad	h	;shift "accumulator" left 1 digit
073D  29      		dad	h
073E  29      		dad	h
073F  29      		dad	h
0740  19      		dad	d	;add in new digit
0741  D1      		pop	d	;restore buffer pointer
0742          		jr	ga0	;loop for next digit
0742  18E9    		DB	18H,ga0-$-1
		
0744  FE20    	chkdlm: cpi	' '	;blank is currently the only valid delimiter
0746  C8      		rz
0747  37      		stc
0748  C9      		ret
		
0749          	hexcon: 		;convert ASCII character to HEX digit
0749  FE30    		cpi	'0'	;must be .GE. "0"
074B  D8      		rc
074C  FE3A    		cpi	'9'+1	;and be .LE. "9"
074E          		jrc	ok0	;valid numeral.
074E  3809    		DB	38H,ok0-$-1
0750  FE41    		cpi	'A'	;or .GE. "A"
0752  D8      		rc
0753  FE47    		cpi	'F'+1	;and .LE. "F"
0755  3F      		cmc
0756  D8      		rc		;return [CY] if not valid HEX digit
0757  D607    		sui	'A'-'9'-1	;convert letter
0759  D630    	ok0:	sui	'0'	;convert (numeral) to 0-15 in (A)
075B  C9      		ret
		
		; These only work on */84 (and 10) models.
		; Have no effect (and does nothing) on */83 models.
075C          	proginit:
075C  AF      		xra	a
075D          		stai
075D  ED47    		DB	0EDH,47H
0000          	 if not rom2k
		 endif
075F  3E41    		mvi	a,'A'
0761  320030  		sta	3000h
0764  C9      		ret
		
0765          	progoff:
0765          		ldai
0765  ED57    		DB	0EDH,57H
0767  C0      		rnz
0768  2F      		cma
0769          		stai
0769  ED47    		DB	0EDH,47H
0000          	 if not rom2k
		 endif
076B  AF      		xra	a
076C  320030  		sta	3000h
076F  C9      		ret
		
0770          	progress:
0770          		ldai
0770  ED57    		DB	0EDH,57H
0772  C0      		rnz
0000          	 if not rom2k
		 endif
0773  3A0030  		lda	3000h
0776  EE03    		xri	00000011b
0778  320030  		sta	3000h
077B  C9      		ret
		
			rept	romsiz-$
077C  FF      		db	0ffh
077D  FF      		db	0ffh
077E  FF      		db	0ffh
077F  FF      		db	0ffh
0780  FF      		db	0ffh
0781  FF      		db	0ffh
0782  FF      		db	0ffh
0783  FF      		db	0ffh
0784  FF      		db	0ffh
0785  FF      		db	0ffh
0786  FF      		db	0ffh
0787  FF      		db	0ffh
0788  FF      		db	0ffh
0789  FF      		db	0ffh
078A  FF      		db	0ffh
078B  FF      		db	0ffh
078C  FF      		db	0ffh
078D  FF      		db	0ffh
078E  FF      		db	0ffh
078F  FF      		db	0ffh
0790  FF      		db	0ffh
0791  FF      		db	0ffh
0792  FF      		db	0ffh
0793  FF      		db	0ffh
0794  FF      		db	0ffh
0795  FF      		db	0ffh
0796  FF      		db	0ffh
0797  FF      		db	0ffh
0798  FF      		db	0ffh
0799  FF      		db	0ffh
079A  FF      		db	0ffh
079B  FF      		db	0ffh
079C  FF      		db	0ffh
079D  FF      		db	0ffh
079E  FF      		db	0ffh
079F  FF      		db	0ffh
07A0  FF      		db	0ffh
07A1  FF      		db	0ffh
07A2  FF      		db	0ffh
07A3  FF      		db	0ffh
07A4  FF      		db	0ffh
07A5  FF      		db	0ffh
07A6  FF      		db	0ffh
07A7  FF      		db	0ffh
07A8  FF      		db	0ffh
07A9  FF      		db	0ffh
07AA  FF      		db	0ffh
07AB  FF      		db	0ffh
07AC  FF      		db	0ffh
07AD  FF      		db	0ffh
07AE  FF      		db	0ffh
07AF  FF      		db	0ffh
07B0  FF      		db	0ffh
07B1  FF      		db	0ffh
07B2  FF      		db	0ffh
07B3  FF      		db	0ffh
07B4  FF      		db	0ffh
07B5  FF      		db	0ffh
07B6  FF      		db	0ffh
07B7  FF      		db	0ffh
07B8  FF      		db	0ffh
07B9  FF      		db	0ffh
07BA  FF      		db	0ffh
07BB  FF      		db	0ffh
07BC  FF      		db	0ffh
07BD  FF      		db	0ffh
07BE  FF      		db	0ffh
07BF  FF      		db	0ffh
07C0  FF      		db	0ffh
07C1  FF      		db	0ffh
07C2  FF      		db	0ffh
07C3  FF      		db	0ffh
07C4  FF      		db	0ffh
07C5  FF      		db	0ffh
07C6  FF      		db	0ffh
07C7  FF      		db	0ffh
07C8  FF      		db	0ffh
07C9  FF      		db	0ffh
07CA  FF      		db	0ffh
07CB  FF      		db	0ffh
07CC  FF      		db	0ffh
07CD  FF      		db	0ffh
07CE  FF      		db	0ffh
07CF  FF      		db	0ffh
07D0  FF      		db	0ffh
07D1  FF      		db	0ffh
07D2  FF      		db	0ffh
07D3  FF      		db	0ffh
07D4  FF      		db	0ffh
07D5  FF      		db	0ffh
07D6  FF      		db	0ffh
07D7  FF      		db	0ffh
07D8  FF      		db	0ffh
07D9  FF      		db	0ffh
07DA  FF      		db	0ffh
07DB  FF      		db	0ffh
07DC  FF      		db	0ffh
07DD  FF      		db	0ffh
07DE  FF      		db	0ffh
07DF  FF      		db	0ffh
07E0  FF      		db	0ffh
07E1  FF      		db	0ffh
07E2  FF      		db	0ffh
07E3  FF      		db	0ffh
07E4  FF      		db	0ffh
07E5  FF      		db	0ffh
07E6  FF      		db	0ffh
07E7  FF      		db	0ffh
07E8  FF      		db	0ffh
07E9  FF      		db	0ffh
07EA  FF      		db	0ffh
07EB  FF      		db	0ffh
07EC  FF      		db	0ffh
07ED  FF      		db	0ffh
07EE  FF      		db	0ffh
07EF  FF      		db	0ffh
07F0  FF      		db	0ffh
07F1  FF      		db	0ffh
07F2  FF      		db	0ffh
07F3  FF      		db	0ffh
07F4  FF      		db	0ffh
07F5  FF      		db	0ffh
07F6  FF      		db	0ffh
07F7  FF      		db	0ffh
07F8  FF      		db	0ffh
07F9  FF      		db	0ffh
07FA  FF      		db	0ffh
07FB  FF      		db	0ffh
07FC  FF      		db	0ffh
07FD  FF      		db	0ffh
07FE  FF      		db	0ffh
07FF  FF      		db	0ffh
		
		; RAM used...
FF00          		org	0ff00h
FF00          	addr0:	ds	2
FF02          	addr1:	ds	2
FF04          	line:	ds	64
		
FF44          		end



Statistics:

     4	passes
     0	jr promotions
   180	symbols
  2048	bytes

   372	macro calls
  3775	macro bytes
     0	invented symbols
