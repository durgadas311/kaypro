		; serial-port ROM monitor/boot for debugging Kaypro.
		; Uses "aux serial" a.k.a "Serial Printer" port.
		
0020          	VERN	equ	020h	; ROM version
		
FFFF          	rom2k	equ	-1
		
FFFF          	 if rom2k
0800          	romsiz	equ	0800h	; space for 2716 ROM
		 else
		 endif
		
			maclib	z80
**** z80.lib ****
**** mon2k.asm ****
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0003          	CTLC	equ	3
0007          	BEL	equ	7
0009          	TAB	equ	9
0008          	BS	equ	8
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
		; WD1943 at 5.0688MHz...
000E          	B9600	equ	0eh
0005          	B300	equ	05h
		; */84 (and 10) sysport drive select
0002          	DS0	equ	0010b
0001          	DS1	equ	0001b
0003          	DSNONE	equ	0011b	; also mask
0010          	K84MTR	equ	00010000b	; */84 (10) MOTOR control, 1=ON
0010          	K83PPS	equ	00010000b	; */83 ParPrt strobe (normally 0)
0040          	K84CCG	equ	01000000b	; */84 (10) CharGen A12
0040          	K83MTR	equ	01000000b	; */83 MOTOR control, 1=OFF
		
0004          	sio1	equ	04h	; "serial data", "keyboard"
000C          	sio2	equ	0ch	; "serial printer", "modem"
0000          	brd1	equ	00h
0008          	brd2	equ	08h
		
0000          	sioA	equ	00h	; offsets
0001          	sioB	equ	01h
		
0000          	sioD	equ	00h	; offsets
0002          	sioC	equ	02h
		
		; Choose Z80SIO port to use...
0004          	condat	equ	sio1+sioA+sioD
0006          	conctl	equ	sio1+sioA+sioC
0000          	conbrr	equ	brd1
		
0005          	kbddat	equ	sio1+sioB+sioD
0007          	kbdctl	equ	sio1+sioB+sioC
000C          	kbdbrr	equ	0ch	; */83 uses WD1943, else hardwired to 300 baud
		
001C          	crtctl	equ	1ch	; */84 and 10 only
001D          	crtdat	equ	1dh	; */84 and 10 only
001F          	crtram	equ	1fh	; also accesses CRTC
		
0014          	sysp84	equ	14h	; sysport on */84 (and 10). */83 have nothing here.
		
0010          	fpysts	equ	10h
0010          	fpycmd	equ	10h
0011          	fpytrk	equ	11h
0012          	fpysec	equ	12h
0013          	fpydat	equ	13h
		
0000          	stack	equ	00000h	; stack at top of memory (wrapped)
		
		; Start of ROM code
0000          		org	00000h
0008          	rst0e	equ	$+8
0000  C36A00  		jmp	init
0003  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0010          	rst1e	equ	$+8
0008  C34B00  	rst1:	jmp	swtrap
000B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0018          	rst2e	equ	$+8
0010  C34B00  	rst2:	jmp	swtrap
0013  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0020          	rst3e	equ	$+8
0018  C34B00  	rst3:	jmp	swtrap
001B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0028          	rst4e	equ	$+8
0020  C34B00  	rst4:	jmp	swtrap
0023  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0030          	rst5e	equ	$+8
0028  C34B00  	rst5:	jmp	swtrap
002B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0038          	rst6e	equ	$+8
0030  C34B00  	rst6:	jmp	swtrap
0033  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
0040          	rst7e	equ	$+8
0038  C34B00  	rst7:	jmp	swtrap
003B  FFFFFFFF		db	0ffh,0ffh,0ffh,0ffh,0ffh
      FF
		
			; NMI not a problem?
		
0040  0D0A2A2A	swt:	db	CR,LF,'*** RST ',TRM
      2A205253
      542000
		
004B  F3      	swtrap:	di		; try to recover return address...
004C  D1      		pop	d	; should be caller of RST...
004D  310000  		lxi	sp,stack
0050  D5      		push	d	; not needed?
0051  214000  		lxi	h,swt
0054  CD4E06  		call	msgprt
0057  D1      		pop	d
0058  CD2506  		call	taddr
005B  CD4406  		call	crlf
			; TODO: print address, etc...
005E  C3DF00  		jmp	debug
		
0061  18      	sioini:	db	18h	; reset
0062  0444    		db	4,044h	; 16x, 1s, Np
0064  03C1    		db	3,0c1h	; 8b, RxEn
0066  05EA    		db	5,0eah	; DTR, 8b, TxEn, RTS
0068  0100    		db	1,000h	;
0009          	siolen	equ	$-sioini
		
		; ROM start point - initialize everything
		; We know we have 64K RAM...
006A  F3      	init:	di
006B  310000  		lxi	sp,stack
		
			; init serial port
006E  3E0E    		mvi	a,B9600
0070  D300    		out	conbrr
0072  216100  		lxi	h,sioini
0075  0E06    		mvi	c,conctl
0077  0609    		mvi	b,siolen
0079          		outir
0079  EDB3    		DB	0EDH,0B3H
		
007B  21BF00  		lxi	h,signon
007E  CD4E06  		call	msgprt
		
0081  CD0607  		call	proginit
			; save registers on stack, for debugger access...
0084  C3DF00  		jmp	debug
		
0087          	belout:
0087  0E07    		mvi	c,BEL
		; Output char to console
		; C=char
0089          	conout:
0089  DB06    		in	conctl
008B  E604    		ani	00000100b
008D          		jrz	conout
008D  28FA    		DB	28H,conout-$-1
008F  79      		mov	a,c
0090  D304    		out	condat
0092  C9      		ret
		
0093  0D0A3A20	prompt:	db	CR,LF,': ',TRM
      00
		
		; Get char from console
		; Returns: A=char, stripped
0098  E5      	conin:	push	h
0099  210000  	ci2:	lxi	h,0
009C  DB06    	ci0:	in	conctl		; 11
009E  E601    		ani	00000001b	;  7
00A0          		jrnz	ci1		;  7
00A0  200A    		DB	20H,ci1-$-1
00A2  2B      		dcx	h		;  6
00A3  7D      		mov	a,l		;  4
00A4  B4      		ora	h		;  4
00A5          		jrnz	ci0		; 12 = 51 (12.75uS) (~0.8 sec)
00A5  20F5    		DB	20H,ci0-$-1
00A7  CD1A07  		call	progress	; on */83 (20.4uS or ~1.3 sec)
00AA          		jr	ci2
00AA  18ED    		DB	18H,ci2-$-1
00AC  DB04    	ci1:	in	condat
00AE  E67F    		ani	07fh
00B0  E1      		pop	h
00B1  C9      		ret
		
		; Get char from console, toupper and echo
00B2          	conine:
00B2  CD9800  		call	conin
00B5  CD6906  		call	toupper
00B8  F5      		push	psw
00B9  4F      		mov	c,a
00BA  CD8900  		call	conout
00BD  F1      		pop	psw
00BE  C9      		ret
		
00BF  0D0A4B61	signon:	db	CR,LF,'Kaypro'
      7970726F
FFFF          	 if rom2k
00C7  2D4949  		db	'-II'
		 endif
00CA  204D6F6E		db	' Monitor v'
      69746F72
      2076
00D4  322E30  	vernum:	db	(VERN SHR 4)+'0','.',(VERN AND 0fh)+'0'
00D7  0D0A00  		db	CR,LF,TRM
		
00DA  0D0A073F	errm:	db	CR,LF,BEL,'?',TRM
      00
		
		*********************************************************
		**  Debug mode
		*********************************************************
		
00DF          	debug:
00DF  310000  	cilp:	lxi	sp,stack
00E2  21DF00  		lxi	h,cilp		;setup return address
00E5  E5      		push	h
00E6  219300  		lxi	h,prompt	;prompt for a command
00E9  CD4E06  		call	msgprt
00EC  CD7206  		call	linein		;wait for command line to be entered
00EF  CD0F07  		call	progoff		; turn off progress indicators
00F2  1104FF  		lxi	d,line
00F5  CDC006  		call	char		;get first character
00F8  C8      		rz			;ignore line if it is empty
00F9  211301  		lxi	h,comnds	;search table for command character
00FC  060B    		mvi	b,ncmnds	;(number of commands)
00FE  BE      	cci0:	cmp	m		;search command table
00FF  23      		inx	h
0100          		jrz	gotocmd		;command was found, execute it
0100  280A    		DB	28H,gotocmd-$-1
0102  23      		inx	h		;step past routine address
0103  23      		inx	h
0104          		djnz	cci0		;loop untill all valid commands are checked
0104  10F8    		DB	10H,cci0-$-1
0106  21DA00  	error:	lxi	h,errm		;if command unknown, beep and re-prompt
0109  C34E06  		jmp	msgprt
		
010C          	gotocmd:
010C  D5      		push	d		;save command line buffer pointer
010D  5E      		mov	e,m		;get command routine address
010E  23      		inx	h
010F  56      		mov	d,m		;DE = routine address
0110  EB      		xchg			;HL = routine address
0111  D1      		pop	d		;restore buffer pointer
0112  E9      		pchl			;jump to command routine
		
		; All commands are started with DE=next char in line buffer
0113          	comnds:
0113  3F      		db	'?'
0114  D502    		dw	Qcomnd
0116  44      		db	'D'
0117  7D03    		dw	Dcomnd
0119  53      		db	'S'
011A  E303    		dw	Scomnd
011C  47      		db	'G'
011D  4B04    		dw	Gcomnd
011F  4D      		db	'M'
0120  DC02    		dw	Mcomnd
0122  46      		db	'F'
0123  3D03    		dw	Fcomnd
0125  49      		db	'I'
0126  8604    		dw	Icomnd
0128  4F      		db	'O'
0129  D804    		dw	Ocomnd
012B  4E      		db	'N'
012C  0D05    		dw	Ncomnd
012E  54      		db	'T'
012F  4F05    		dw	Tcomnd
0131  56      		db	'V'
0132  1F06    		dw	Vcomnd
000B          	ncmnds	equ	($-comnds)/3
		
		*********************************************************
		**  Command subroutines
		*********************************************************
		
0134          	menu:
0134  0D0A4420		db	CR,LF,'D <start> <end> - display memory in HEX'
      3C737461
      72743E20
      3C656E64
      3E202D20
      64697370
      6C617920
      6D656D6F
      72792069
      6E204845
      58
015D  0D0A5320		db	CR,LF,'S <start> - set/view memory'
      3C737461
      72743E20
      2D207365
      742F7669
      6577206D
      656D6F72
      79
017A  0D0A2020		db	CR,LF,'    (CR) = skip fwd, ''-'' = skip bkwd, ''.'' = done'
      20202843
      5229203D
      20736B69
      70206677
      642C2027
      2D27203D
      20736B69
      7020626B
      77642C20
      272E2720
      3D20646F
      6E65
01AC  0D0A4720		db	CR,LF,'G <start> - go to address'
      3C737461
      72743E20
      2D20676F
      20746F20
      61646472
      657373
01C7  0D0A4620		db	CR,LF,'F <start> <end> <data> - fill memory'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6174613E
      202D2066
      696C6C20
      6D656D6F
      7279
01ED  0D0A4D20		db	CR,LF,'M <start> <end> <dest> - Move data'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6573743E
      202D204D
      6F766520
      64617461
0211  0D0A4920		db	CR,LF,'I <port> [num] - Input from port'
      3C706F72
      743E205B
      6E756D5D
      202D2049
      6E707574
      2066726F
      6D20706F
      7274
0233  0D0A4F20		db	CR,LF,'O <port> <value> [...] - Output to port'
      3C706F72
      743E203C
      76616C75
      653E205B
      2E2E2E5D
      202D204F
      75747075
      7420746F
      20706F72
      74
025C  0D0A4E20		db	CR,LF,'N <hw> - iNitialize hardware (KB83'
      3C68773E
      202D2069
      4E697469
      616C697A
      65206861
      72647761
      72652028
      4B423833
0000          	 if not rom2k
		 endif
0280  29      		db		')'
0281  0D0A5420		db	CR,LF,'T <hw> - Test hardware (KBD'
      3C68773E
      202D2054
      65737420
      68617264
      77617265
      20284B42
      44
0000          	 if not rom2k
		 endif
029E  2C20464C		db		', FLPY)'
      505929
02A5  0D0A5620		db	CR,LF,'V - Show ROM version'
      2D205368
      6F772052
      4F4D2076
      65727369
      6F6E
02BB  0D0A5E43		db	CR,LF,'^C aborts command entry'
      2061626F
      72747320
      636F6D6D
      616E6420
      656E7472
      79
02D4  00      		db	TRM
		
02D5          	Qcomnd:
02D5  213401  		lxi	h,menu
02D8  CD4E06  		call	msgprt
02DB  C9      		ret
		
02DC  CDCC06  	Mcomnd:	call	getaddr
02DF  DA0601  		jc	error
02E2          		bit	7,b
02E2  CB78    		DB	0CBH,7*8+b+40H
02E4  C20601  		jnz	error
02E7  2200FF  		shld	addr0
02EA  CDCC06  		call	getaddr
02ED  DA0601  		jc	error
02F0          		bit	7,b
02F0  CB78    		DB	0CBH,7*8+b+40H
02F2  C20601  		jnz	error
02F5  2202FF  		shld	addr1
02F8  CDCC06  		call	getaddr
02FB  DA0601  		jc	error
02FE          		bit	7,b
02FE  CB78    		DB	0CBH,7*8+b+40H
0300  C20601  		jnz	error
0303  EB      		xchg
0304          		lbcd	addr0
0304  ED4B    		DB	0EDH,4BH
0306  00FF    		DW	addr0
0308  2A02FF  		lhld	addr1
030B  B7      		ora	a
030C          		dsbc	b
030C  ED42    		DB	0EDH,b*8+42H
030E  DA0601  		jc	error
0311  23      		inx	h
0312  4D      		mov	c,l
0313  44      		mov	b,h
0314  D5      		push	d
0315  EB      		xchg
0316  09      		dad	b
0317  D1      		pop	d
0318  DA0601  		jc	error
031B  2A02FF  		lhld	addr1
031E  CD6306  		call	check
0321  DA3703  		jc	mc0
0324  2A00FF  		lhld	addr0
0327  CD6306  		call	check
032A  D23703  		jnc	mc0
032D  2A02FF  		lhld	addr1
0330  EB      		xchg
0331  09      		dad	b
0332  2B      		dcx	h
0333  EB      		xchg
0334          		lddr
0334  EDB8    		DB	0EDH,0B8H
0336  C9      		ret
0337  2A00FF  	mc0:	lhld	addr0
033A          		ldir
033A  EDB0    		DB	0EDH,0B0H
033C  C9      		ret
033D          	Fcomnd:
033D  CDCC06  		call	getaddr ;get address to start at
0340  DA0601  		jc	error	;error if non-hex character
0343          		bit	7,b	;test for no address (different from 0000)
0343  CB78    		DB	0CBH,7*8+b+40H
0345  C20601  		jnz	error	;error if no address was entered
0348  2200FF  		shld	addr0	;save starting address
034B  CDCC06  		call	getaddr ;get stop address
034E  DA0601  		jc	error	;error if non-hex character
0351          		bit	7,b	;test for no entry
0351  CB78    		DB	0CBH,7*8+b+40H
0353  C20601  		jnz	error	;error if no stop address
0356  2202FF  		shld	addr1	;save stop address
0359  CDCC06  		call	getaddr ;get fill data
035C  DA0601  		jc	error	;error if non-hex character
035F          		bit	7,b	;test for no entry
035F  CB78    		DB	0CBH,7*8+b+40H
0361  C20601  		jnz	error	;error if no fill data
0364  7C      		mov	a,h
0365  B7      		ora	a
0366  C20601  		jnz	error
0369  4D      		mov	c,l	;(C)=fill data
036A  2A02FF  		lhld	addr1	;get stop address
036D          		lded	addr0	;get start address
036D  ED5B    		DB	0EDH,5BH
036F  00FF    		DW	addr0
0371  79      	fc0:	mov	a,c	;
0372  12      		stax	d	;put byte in memory
0373  13      		inx	d	;step to next byte
0374  7A      		mov	a,d	;
0375  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
0376  C8      		rz		;
0377  CD6306  		call	check	;test for past stop address
037A  D8      		rc	;quit if past stop address
037B          		jr	fc0
037B  18F4    		DB	18H,fc0-$-1
		
037D          	Dcomnd:		;display memory
037D  CDCC06  		call	getaddr ;get address to start at
0380  DA0601  		jc	error	;error if non-hex character
0383          		bit	7,b	;test for no address (different from 0000)
0383  CB78    		DB	0CBH,7*8+b+40H
0385  C20601  		jnz	error	;error if no address was entered
0388  2200FF  		shld	addr0	;save starting address
038B  CDCC06  		call	getaddr ;get stop address
038E  DA0601  		jc	error	;error if non-hex character
0391          		bit	7,b	;test for no entry
0391  CB78    		DB	0CBH,7*8+b+40H
0393  C20601  		jnz	error	;error if no stop address
0396          		lded	addr0	;get start address into (DE)
0396  ED5B    		DB	0EDH,5BH
0398  00FF    		DW	addr0
039A  CD4406  	dis0:	call	crlf	;start on new line
039D  CD2506  		call	taddr	;print current address
03A0  CD3F06  		call	space	;delimit it from data
03A3  0610    		mvi	b,16	;display 16 bytes on each line
03A5  1A      	dis1:	ldax	d	;get byte to display
03A6  13      		inx	d	;step to next byte
03A7  CD2A06  		call	hexout	;display this byte in HEX
03AA  CD3F06  		call	space	;delimit it from others
03AD  7A      		mov	a,d
03AE  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03AF          		jrz	dis2
03AF  2807    		DB	28H,dis2-$-1
03B1  CD6306  		call	check	;test for past stop address
03B4          		jrc	dis2	;quit if past stop address
03B4  3802    		DB	38H,dis2-$-1
03B6          		djnz	dis1	;else do next byte on this line
03B6  10ED    		DB	10H,dis1-$-1
03B8  CD3F06  	dis2:	call	space	;delimit it from data
03BB  CD3F06  		call	space
03BE          		lded	addr0
03BE  ED5B    		DB	0EDH,5BH
03C0  00FF    		DW	addr0
03C2  0610    		mvi	b,16	;display 16 bytes on each line
03C4  1A      	dis3:	ldax	d	;get byte to display
03C5  13      		inx	d	;step to next byte
03C6  0E2E    		mvi	c,'.'
03C8  FE20    		cpi	' '
03CA          		jrc	dis4
03CA  3805    		DB	38H,dis4-$-1
03CC  FE7F    		cpi	'~'+1
03CE          		jrnc	dis4
03CE  3001    		DB	30H,dis4-$-1
03D0  4F      		mov	c,a
03D1  CD8900  	dis4:	call	conout
03D4  7A      		mov	a,d
03D5  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03D6  C8      		rz
03D7  CD6306  		call	check	;test for past stop address
03DA  D8      		rc	;quit if past stop address
03DB          		djnz	dis3	;else do next byte on this line
03DB  10E7    		DB	10H,dis3-$-1
03DD          		sded	addr0
03DD  ED53    		DB	0EDH,53H
03DF  00FF    		DW	addr0
03E1          		jr	dis0	;when line is finished, start another
03E1  18B7    		DB	18H,dis0-$-1
		
03E3          	Scomnd: 		;substitute (set) memory
03E3  CDCC06  		call	getaddr ;get address to start substitution at
03E6  DA0601  		jc	error	;error if non-hex character
03E9          		bit	7,b	;test for no entry
03E9  CB78    		DB	0CBH,7*8+b+40H
03EB  C20601  		jnz	error	;error if no address
03EE  EB      		xchg		;put address in (DE)
03EF  CD4406  	sb1:	call	crlf	;start on new line
03F2  CD2506  		call	taddr	;print address
03F5  CD3F06  		call	space	;and delimit it
03F8  1A      		ldax	d	;get current value of byte
03F9  CD2A06  		call	hexout	;and display it
03FC  CD3F06  		call	space	;delimit it from user's (posible) entry
03FF  0600    		mvi	b,0	;zero accumilator for user's entry
0401  CDB200  	sb2:	call	conine	;get user's first character
0404  FE0D    		cpi	CR	;if CR then skip to next byte
0406          		jrz	foward
0406  2833    		DB	28H,foward-$-1
0408  FE20    		cpi	' '	;or if Space then skip to next
040A          		jrz	foward
040A  282F    		DB	28H,foward-$-1
040C  FE2D    		cpi	'-'	;if Minus then step back to previous address
040E          		jrz	bakwrd
040E  282E    		DB	28H,bakwrd-$-1
0410  FE2E    		cpi	'.'	;if Period then stop substitution
0412  C8      		rz
0413  CDF306  		call	hexcon	;if none of the above, should be HEX digit
0416          		jrc	error0	;error if not
0416  3829    		DB	38H,error0-$-1
0418          		jr	sb3	;start accumilating HEX digits
0418  1805    		DB	18H,sb3-$-1
041A  CDF306  	sb0:	call	hexcon	;test for HEX digit
041D          		jrc	error1	;error if not HEX
041D  3827    		DB	38H,error1-$-1
041F          	sb3:	slar	b	;roll accumilator to receive new digit
041F  CB20    		DB	0CBH, 20H + b
0421          		slar	b
0421  CB20    		DB	0CBH, 20H + b
0423          		slar	b
0423  CB20    		DB	0CBH, 20H + b
0425          		slar	b
0425  CB20    		DB	0CBH, 20H + b
0427  B0      		ora	b	;merge in new digit
0428  47      		mov	b,a
0429  CDB200  	sb4:	call	conine	;get next character
042C  FE0D    		cpi	CR	;if CR then put existing byte into memory
042E          		jrz	putbyte ;  and step to next.
042E  2809    		DB	28H,putbyte-$-1
0430  FE2E    		cpi	'.'
0432  C8      		rz
0433  FE7F    		cpi	del	;if DEL then restart at same address
0435          		jrz	sb1
0435  28B8    		DB	28H,sb1-$-1
0437          		jr	sb0	;else continue entering hex digits
0437  18E1    		DB	18H,sb0-$-1
0439          	putbyte:
0439  78      		mov	a,b	;store accumilated byte in memory
043A  12      		stax	d
043B          	foward:
043B  13      		inx	d	;step to next location
043C          		jr	sb1	;and allow substitution there
043C  18B1    		DB	18H,sb1-$-1
		
043E          	bakwrd:
043E  1B      		dcx	d	;move address backward one location
043F          		jr	sb1
043F  18AE    		DB	18H,sb1-$-1
		
0441  CD8700  	error0:	call	belout	;user's entry was not valid, beep and continue
0444          		jr	sb2
0444  18BB    		DB	18H,sb2-$-1
0446  CD8700  	error1:	call	belout	;same as above but for different section of routine
0449          		jr	sb4
0449  18DE    		DB	18H,sb4-$-1
		
044B          	Gcomnd: 		;jump to address given by user
044B  CDCC06  		call	getaddr ;get address to jump to
044E  DA0601  		jc	error	;error if non-hex character
0451          		bit	7,b	;test for no entry
0451  CB78    		DB	0CBH,7*8+b+40H
0453  C20601  		jnz	error	;error if no address entered
0456  CD4406  		call	crlf	;on new line,
0459  0E47    		mvi	c,'G'	;display "GO aaaa?" to ask
045B  CD8900  		call	conout	;user to verify that we should
045E  0E4F    		mvi	c,'O'	;jump to this address (in case user
0460  CD8900  		call	conout	;made a mistake we should not blindly
0463  CD3F06  		call	space	;commit suicide)
0466  EB      		xchg
0467  CD2506  		call	taddr
046A  CD3F06  		call	space
046D  0E3F    		mvi	c,'?'
046F  CD8900  		call	conout
0472  CDB200  		call	conine	;wait for user to type "Y" to
0475  FE59    		cpi	'Y'	;indicate that we should jump.
0477  C0      		rnz		;abort if response was not "Y"
0478  CD4406  		call	crlf	; visual feedback
047B  EB      		xchg
047C  E9      		pchl		;else jump to address
		
047D  0D0A496E	inpms:	db	CR,LF,'Input ',TRM
      70757420
      00
0486          	Icomnd:
0486  CDCC06  		call	getaddr ;get port address, ignore extra MSDs
0489  DA0601  		jc	error	;error if non-hex character
048C          		bit	7,b	;test for no entry
048C  CB78    		DB	0CBH,7*8+b+40H
048E  C20601  		jnz	error	;error if no address entered
0491  E5      		push	h	; save port
0492  CDCC06  		call	getaddr	; hex number of inputs to do
0495  DA0601  		jc	error
0498          		bit	7,b
0498  CB78    		DB	0CBH,7*8+b+40H
049A          		jrz	ic0
049A  2803    		DB	28H,ic0-$-1
049C  210100  		lxi	h,1
049F          	ic0:
049F  E3      		xthl		; save count
04A0  E5      		push	h	; re-save port
04A1  217D04  		lxi	h,inpms
04A4  CD4E06  		call	msgprt
04A7  E1      		pop	h
04A8  E5      		push	h
04A9  7D      		mov	a,l
04AA  CD2A06  		call	hexout
04AD  CD3F06  		call	space
04B0  0E3D    		mvi	c,'='
04B2  CD8900  		call	conout
			; "Input XX ="
04B5  C1      		pop	b	; port to BC
04B6  E1      		pop	h	; count to HL (L)
04B7  260D    		mvi	h,16-3
04B9  0600    		mvi	b,0	; safety
04BB  C5      		push	b	; C gets trashed by conout
04BC          	ic1:
04BC  CD3F06  		call	space
04BF  C1      		pop	b
04C0  C5      		push	b
04C1          		inp	a
04C1  ED78    		DB	0EDH,a*8+40H
04C3  CD2A06  		call	hexout
04C6  2D      		dcr	l	; assume <= 256
04C7          		jrz	ic2
04C7  280A    		DB	28H,ic2-$-1
04C9  25      		dcr	h	; col count
04CA          		jrnz	ic1
04CA  20F0    		DB	20H,ic1-$-1
04CC  CD4406  		call	crlf
04CF  2610    		mvi	h,16
04D1          		jr	ic1
04D1  18E9    		DB	18H,ic1-$-1
04D3          	ic2:
04D3  C1      		pop	b	; fix stack
04D4  CD4406  		call	crlf
04D7  C9      		ret
		
		; TODO: no feedback?
04D8          	Ocomnd:
04D8  CDCC06  		call	getaddr ;get port address, ignore extra MSDs
04DB  DA0601  		jc	error	;error if non-hex character
04DE          		bit	7,b	;test for no entry
04DE  CB78    		DB	0CBH,7*8+b+40H
04E0  C20601  		jnz	error	;error if no address entered
04E3  2600    		mvi	h,0	; safety
04E5  E5      		push	h	; save port
04E6  CDCC06  		call	getaddr ;get value, ignore extra MSDs
04E9  DA0601  		jc	error	;error if non-hex character
04EC          		bit	7,b	;test for no entry
04EC  CB78    		DB	0CBH,7*8+b+40H
04EE  C20601  		jnz	error	;error if no value entered
04F1  CD4406  		call	crlf
04F4          	oc0:		; L has byte to output...
04F4  C1      		pop	b	; port
04F5  C5      		push	b
04F6          		outp	l
04F6  ED69    		DB	0EDH,l*8+41H
04F8  CDCC06  		call	getaddr ;get value, ignore extra MSDs
04FB  DA0601  		jc	error	;error if non-hex character
					;NOTE: some output has been sent
04FE          		bit	7,b	;test for no entry
04FE  CB78    		DB	0CBH,7*8+b+40H
0500          		jrz	oc0	;still more to send
0500  28F2    		DB	28H,oc0-$-1
0502  E1      		pop	h	; discard port
0503  C9      		ret
		
0504  CDC006  	skb:	call	char
0507  C8      		rz		;end of buffer/line before a character was found (ZR)
0508  FE20    		cpi	' '	;skip all leading spaces
050A  C0      		rnz		;if not space, then done (NZ)
050B          		jr	skb	;else if space, loop untill not space
050B  18F7    		DB	18H,skb-$-1
		
050D          	Ncomnd:
050D  CD0405  		call	skb	; skip blanks
0510  CA0601  		jz	error	; required param
			; this may need refinement
0513  1B      		dcx	d
0514  211F05  		lxi	h,kb83
0517  CD3B05  		call	strcmp
051A          		jrz	nkb83
051A  2811    		DB	28H,nkb83-$-1
0000          	 if not rom2k
		 endif
051C  C30601  		jmp	error
		
051F  4B423833	kb83:	db	'KB83',TRM
      00
0000          	 if not rom2k
		 endif
0524  464C5059	flpy:	db	'FLPY',TRM
      00
0529  4B424400	kbd:	db	'KBD',TRM
		
052D  3E05    	nkb83:	mvi	a,B300
052F  D30C    		out	kbdbrr	; */83 baud gen for SIO1 ch B
0531  216100  	nkb84:	lxi	h,sioini
0534  0E07    		mvi	c,kbdctl
0536  0609    		mvi	b,siolen
0538          		outir
0538  EDB3    		DB	0EDH,0B3H
053A  C9      		ret
		
0000          	 if not rom2k
		 endif
		
		; if match, return DE after last match.
		; if no match, return original DE.
053B  D5      	strcmp:	push	d
053C  AF      		xra	a
053D  BE      	sc0:	cmp	m	; TRM?
053E          		jrz	sc9	; A = 0
053E  2808    		DB	28H,sc9-$-1
0540  1A      		ldax	d
0541  96      		sub	m
0542          		jrnz	sc8	; A is NZ
0542  2008    		DB	20H,sc8-$-1
0544  23      		inx	h
0545  13      		inx	d
0546          		jr	sc0
0546  18F5    		DB	18H,sc0-$-1
0548  33      	sc9:	inx	sp	; non-destructive POP
0549  33      		inx	sp
054A  AF      		xra	a	; A=0 and ZR
054B  C9      		ret
054C  D1      	sc8:	pop	d	; restore orig location
054D  B7      		ora	a
054E  C9      		ret
		
054F          	Tcomnd:
054F  CD0405  		call	skb	; skip blanks
0552  CA0601  		jz	error	; required param
			; this may need refinement
0555  1B      		dcx	d
0556  212905  		lxi	h,kbd
0559  CD3B05  		call	strcmp
055C          		jrz	tkbd
055C  280C    		DB	28H,tkbd-$-1
0000          	 if not rom2k
		 endif
055E  212405  		lxi	h,flpy
0561  CD3B05  		call	strcmp
0564  CAA005  		jz	tflpy
0567  C30601  		jmp	error
		
0000          	 if not rom2k
		 endif
		
056A  218F05  	tkbd:	lxi	h,waitm
056D  CD4E06  		call	msgprt
0570  DB07    	tk0:	in	kbdctl
0572  E601    		ani	00000001b
0574          		jrnz	tk1
0574  200F    		DB	20H,tk1-$-1
0576  DB06    		in	conctl
0578  E601    		ani	00000001b
057A          		jrz	tk0
057A  28F4    		DB	28H,tk0-$-1
057C  DB04    		in	condat
057E  219A05  		lxi	h,abrtm
0581  CD4E06  		call	msgprt
0584  C9      		ret
0585  DB05    	tk1:	in	kbddat
0587  CD2A06  		call	hexout
058A  CD3F06  		call	space
058D          		jr	tk0
058D  18E1    		DB	18H,tk0-$-1
		
058F  0D0A5761	waitm:	db	CR,LF,'Wait... ',TRM
      69742E2E
      2E2000
059A  41626F72	abrtm:	db	'Abort',TRM
      7400
0000          	 if not rom2k
		 endif
		
05A0          	tflpy:	; user must motor on and select drive (and side)
05A0  3ED0    		mvi	a,0d0h
05A2  3200FF  		sta	addr0	; default: force intr
05A5  AF      		xra	a
05A6  3202FF  		sta	addr1	; default: 256 samples
			; TODO: parse optional args
05A9  CDCC06  		call	getaddr ;get optional command
05AC  DA0601  		jc	error	;error if non-hex character
05AF          		bit	7,b	;test for no entry
05AF  CB78    		DB	0CBH,7*8+b+40H
05B1          		jrnz	tfX
05B1  201B    		DB	20H,tfX-$-1
05B3  7C      		mov	a,h
05B4  B7      		ora	a
05B5  C20601  		jnz	error
05B8  2200FF  		shld	addr0	;save command
05BB  CDCC06  		call	getaddr ;get fill data
05BE  DA0601  		jc	error	;error if non-hex character
05C1          		bit	7,b	;test for no entry
05C1  CB78    		DB	0CBH,7*8+b+40H
05C3  C2CE05  		jnz	tfX
05C6  7C      		mov	a,h
05C7  B7      		ora	a
05C8  C20601  		jnz	error
05CB  2202FF  		shld	addr1	;save count
05CE          	tfX:
05CE  CD4406  		call	crlf
05D1  DB10    		in	fpysts
05D3  4F      		mov	c,a
05D4  3A00FF  		lda	addr0	; FDC command
05D7  D310    		out	fpycmd
05D9  210000  		lxi	h,0
05DC  110080  		lxi	d,8000h
		
05DF  DB10    	tf0:	in	fpysts	; 11
05E1  B9      		cmp	c	;  4
05E2          		jrnz	tf4	;  7
05E2  2027    		DB	20H,tf4-$-1
05E4  23      	tf5:	inx	h	;  6
05E5  7C      		mov	a,h	;  4
05E6  B5      		ora	l	;  4
05E7          		jrnz	tf0	; 12 = 48 = 12uS
05E7  20F6    		DB	20H,tf0-$-1
05E9          	tf1:	; dump 8000h..DE
05E9  210080  		lxi	h,8000h
05EC          	tf2:
05EC  7C      		mov	a,h
05ED  BA      		cmp	d
05EE          		jrnz	tf3
05EE  2003    		DB	20H,tf3-$-1
05F0  7D      		mov	a,l
05F1  BB      		cmp	e
05F2  C8      		rz	; user must motor off...
05F3          	tf3:
05F3  7E      		mov	a,m
05F4  23      		inx	h
05F5  CD2A06  		call	hexout
05F8  CD3F06  		call	space
05FB  46      		mov	b,m
05FC  23      		inx	h
05FD  7E      		mov	a,m
05FE  23      		inx	h
05FF  CD2A06  		call	hexout
0602  78      		mov	a,b
0603  CD2A06  		call	hexout
0606  CD4406  		call	crlf
0609          		jr	tf2
0609  18E1    		DB	18H,tf2-$-1
		
		; save sample, check for done.
060B  EB      	tf4:	xchg
060C  77      		mov	m,a
060D  23      		inx	h
060E  73      		mov	m,e
060F  23      		inx	h
0610  72      		mov	m,d
0611  23      		inx	h
0612  EB      		xchg
0613  4F      		mov	c,a
0614  3A02FF  		lda	addr1
0617  3D      		dcr	a
0618  3202FF  		sta	addr1
061B          		jrz	tf1
061B  28CC    		DB	28H,tf1-$-1
061D          		jr	tf5
061D  18C5    		DB	18H,tf5-$-1
		
061F          	Vcomnd:
061F  21BF00  		lxi	h,signon
0622  C34E06  		jmp	msgprt
		
		*********************************************************
		**  Utility subroutines
		*********************************************************
		
0625  7A      	taddr:	mov	a,d	;display (DE) at console in HEX
0626  CD2A06  		call	hexout	;print HI byte in HEX
0629  7B      		mov	a,e	;now do LO byte
062A  F5      	hexout:	push	psw	;output (A) to console in HEX
062B  07      		rlc		;get HI digit in usable (LO) position
062C  07      		rlc
062D  07      		rlc
062E  07      		rlc
062F  CD3306  		call	nible	;and display it
0632  F1      		pop	psw	;get LO digit back and display it
0633  E60F    	nible:	ani	00001111b	;display LO 4 bits of (A) in HEX
0635  C690    		adi	90h	;algorithm to convert 4-bits to ASCII
0637  27      		daa
0638  CE40    		aci	40h
063A  27      		daa
063B  4F      		mov	c,a	;display ASCII digit
063C  C38900  		jmp	conout
		
063F  0E20    	space:	mvi	c,' '	;send an ASCII blank to console
0641  C38900  		jmp	conout
		
0644  0E0D    	crlf:	mvi	c,CR	;send Carriage-Return/Line-Feed to console
0646  CD8900  		call	conout
0649  0E0A    		mvi	c,LF
064B  C38900  		jmp	conout
		
064E  7E      	msgprt:	mov	a,m	;send string to console, terminated by 00
064F  B7      		ora	a
0650  C8      		rz
0651  4F      		mov	c,a
0652  CD8900  		call	conout
0655  23      		inx	h
0656          		jr	msgprt
0656  18F6    		DB	18H,msgprt-$-1
		
0658  7E      	print:	mov	a,m	; BDOS func 9 style msgprt
0659  FE24    		cpi	'$'
065B  C8      		rz
065C  4F      		mov	c,a
065D  CD8900  		call	conout
0660  23      		inx	h
0661          		jr	print
0661  18F5    		DB	18H,print-$-1
		
0663  E5      	check:	push	h	;non-destuctive compare HL:DE
0664  B7      		ora	a
0665          		dsbc	d
0665  ED52    		DB	0EDH,d*8+42H
0667  E1      		pop	h
0668  C9      		ret
		
		; Convert letters to upper-case
0669          	toupper:
0669  FE61    		cpi	'a'
066B  D8      		rc
066C  FE7B    		cpi	'z'+1
066E  D0      		rnc
066F  E65F    		ani	01011111b
0671  C9      		ret
		
		; Read a line of text into 'line'
		; End with CR, honor BS
		; Reject all non-printing characters, force toupper
0672  2104FF  	linein:	lxi	h,line	;get string of characters from console, ending in CR
0675  CD9800  	li0:	call	conin	;get a character
0678  FE08    		cpi	BS	;allow BackSpacing
067A          		jrz	backup
067A  281D    		DB	28H,backup-$-1
067C  FE0D    		cpi	CR
067E          		jrz	li1
067E  282E    		DB	28H,li1-$-1
0680  FE03    		cpi	CTLC
0682          		jrz	liZ
0682  2830    		DB	28H,liZ-$-1
0684  FE20    		cpi	' '	;ignore other non-print
0686          		jrc	li0
0686  38ED    		DB	38H,li0-$-1
0688  CD6906  		call	toupper
068B  77      		mov	m,a	;put character in line nuffer
068C  23      		inx	h
068D  4F      		mov	c,a
068E  CD8900  		call	conout	; echo character
0691  7D      		mov	a,l	;else check for pending buffer overflow
0692  D604    		sui	line mod 256
0694  FE40    		cpi	64
0696  C8      		rz		;stop if buffer full
0697          		jr	li0	;if not full, keep getting characters
0697  18DC    		DB	18H,li0-$-1
		
0699  7D      	backup:	mov	a,l	;(destructive) BackSpacing
069A  FE04    		cpi	line mod 256	;test if at beginning of line
069C          		jrz	li0	;can't backspace past start of line
069C  28D7    		DB	28H,li0-$-1
069E  0E08    		mvi	c,bs	;output BS," ",BS to erase character on screen
06A0  CD8900  		call	conout	;and put cursor back one position
06A3  CD3F06  		call	space
06A6  0E08    		mvi	c,bs
06A8  CD8900  		call	conout
06AB  2B      		dcx	h	;step buffer pointer back one
06AC          		jr	li0	;and continue to get characters
06AC  18C7    		DB	18H,li0-$-1
		
		; End line input, A=CR
06AE  77      	li1:	mov	m,a	; store CR in buffer
06AF  0E0D    		mvi	c,CR	;display CR so user knows we got it
06B1  C38900  		jmp	conout	;then return to calling routine
		
		; Abort input
06B4  0E5E    	liZ:	mvi	c,'^'
06B6  CD8900  		call	conout
06B9  0E43    		mvi	c,'C'
06BB  CD8900  		call	conout
06BE  E1      		pop	h	; always OK?
06BF  C9      		ret		; return to caller's caller (main debug loop)
		
		; Get next character from line buffer.
		; DE=current pointer within 'line'
		; Returns: ZR=EOL else A=char
06C0  7B      	char:	mov	a,e	;remove a character from line buffer,
06C1  D604    		sui	line mod 256	;testing for no more characters
06C3  D640    		sui	64
06C5  C8      		rz		;return [ZR] condition if at end of buffer
06C6  1A      		ldax	d
06C7  FE0D    		cpi	CR
06C9  C8      		rz		;also return [ZR] if at end of line
06CA  13      		inx	d	;else step to next character
06CB  C9      		ret		;and return [NZ]
		
		; Get HEX value from line buffer
		; Return: CY=error, HL=value, bit7(B)=1 if no input
06CC          	getaddr:		;extract address from line buffer (delimitted by " ")
06CC          		setb	7,b	;flag to detect no address entered
06CC  CBF8    		DB	0CBH,7*8+b+0C0H
06CE  210000  		lxi	h,0
06D1  CD0405  		call	skb
06D4  C8      		rz		;end of buffer/line before a character was found
06D5          		jr	ga1	;if not space, then start getting HEX digits
06D5  1804    		DB	18H,ga1-$-1
		
06D7  CDC006  	ga0:	call	char
06DA  C8      		rz
06DB  CDF306  	ga1:	call	hexcon	;start assembling digits into 16 bit accumilator
06DE          		jrc	chkdlm	;check if valid delimiter before returning error.
06DE  380E    		DB	38H,chkdlm-$-1
06E0          		res	7,b	;reset flag
06E0  CBB8    		DB	0CBH,7*8+b+80H
06E2  D5      		push	d	;save buffer pointer
06E3  5F      		mov	e,a
06E4  1600    		mvi	d,0
06E6  29      		dad	h	;shift "accumulator" left 1 digit
06E7  29      		dad	h
06E8  29      		dad	h
06E9  29      		dad	h
06EA  19      		dad	d	;add in new digit
06EB  D1      		pop	d	;restore buffer pointer
06EC          		jr	ga0	;loop for next digit
06EC  18E9    		DB	18H,ga0-$-1
		
06EE  FE20    	chkdlm: cpi	' '	;blank is currently the only valid delimiter
06F0  C8      		rz
06F1  37      		stc
06F2  C9      		ret
		
06F3          	hexcon: 		;convert ASCII character to HEX digit
06F3  FE30    		cpi	'0'	;must be .GE. "0"
06F5  D8      		rc
06F6  FE3A    		cpi	'9'+1	;and be .LE. "9"
06F8          		jrc	ok0	;valid numeral.
06F8  3809    		DB	38H,ok0-$-1
06FA  FE41    		cpi	'A'	;or .GE. "A"
06FC  D8      		rc
06FD  FE47    		cpi	'F'+1	;and .LE. "F"
06FF  3F      		cmc
0700  D8      		rc		;return [CY] if not valid HEX digit
0701  D607    		sui	'A'-'9'-1	;convert letter
0703  D630    	ok0:	sui	'0'	;convert (numeral) to 0-15 in (A)
0705  C9      		ret
		
		; These only work on */84 (and 10) models.
		; Have no effect (and does nothing) on */83 models.
0706          	proginit:
0706  AF      		xra	a
0707          		stai
0707  ED47    		DB	0EDH,47H
0000          	 if not rom2k
		 endif
0709  3E41    		mvi	a,'A'
070B  320030  		sta	3000h
070E  C9      		ret
		
070F          	progoff:
070F          		ldai
070F  ED57    		DB	0EDH,57H
0711  C0      		rnz
0712  2F      		cma
0713          		stai
0713  ED47    		DB	0EDH,47H
0000          	 if not rom2k
		 endif
0715  AF      		xra	a
0716  320030  		sta	3000h
0719  C9      		ret
		
071A          	progress:
071A          		ldai
071A  ED57    		DB	0EDH,57H
071C  C0      		rnz
0000          	 if not rom2k
		 endif
071D  3A0030  		lda	3000h
0720  EE03    		xri	00000011b
0722  320030  		sta	3000h
0725  C9      		ret
		
			rept	romsiz-$
0726  FF      		db	0ffh
0727  FF      		db	0ffh
0728  FF      		db	0ffh
0729  FF      		db	0ffh
072A  FF      		db	0ffh
072B  FF      		db	0ffh
072C  FF      		db	0ffh
072D  FF      		db	0ffh
072E  FF      		db	0ffh
072F  FF      		db	0ffh
0730  FF      		db	0ffh
0731  FF      		db	0ffh
0732  FF      		db	0ffh
0733  FF      		db	0ffh
0734  FF      		db	0ffh
0735  FF      		db	0ffh
0736  FF      		db	0ffh
0737  FF      		db	0ffh
0738  FF      		db	0ffh
0739  FF      		db	0ffh
073A  FF      		db	0ffh
073B  FF      		db	0ffh
073C  FF      		db	0ffh
073D  FF      		db	0ffh
073E  FF      		db	0ffh
073F  FF      		db	0ffh
0740  FF      		db	0ffh
0741  FF      		db	0ffh
0742  FF      		db	0ffh
0743  FF      		db	0ffh
0744  FF      		db	0ffh
0745  FF      		db	0ffh
0746  FF      		db	0ffh
0747  FF      		db	0ffh
0748  FF      		db	0ffh
0749  FF      		db	0ffh
074A  FF      		db	0ffh
074B  FF      		db	0ffh
074C  FF      		db	0ffh
074D  FF      		db	0ffh
074E  FF      		db	0ffh
074F  FF      		db	0ffh
0750  FF      		db	0ffh
0751  FF      		db	0ffh
0752  FF      		db	0ffh
0753  FF      		db	0ffh
0754  FF      		db	0ffh
0755  FF      		db	0ffh
0756  FF      		db	0ffh
0757  FF      		db	0ffh
0758  FF      		db	0ffh
0759  FF      		db	0ffh
075A  FF      		db	0ffh
075B  FF      		db	0ffh
075C  FF      		db	0ffh
075D  FF      		db	0ffh
075E  FF      		db	0ffh
075F  FF      		db	0ffh
0760  FF      		db	0ffh
0761  FF      		db	0ffh
0762  FF      		db	0ffh
0763  FF      		db	0ffh
0764  FF      		db	0ffh
0765  FF      		db	0ffh
0766  FF      		db	0ffh
0767  FF      		db	0ffh
0768  FF      		db	0ffh
0769  FF      		db	0ffh
076A  FF      		db	0ffh
076B  FF      		db	0ffh
076C  FF      		db	0ffh
076D  FF      		db	0ffh
076E  FF      		db	0ffh
076F  FF      		db	0ffh
0770  FF      		db	0ffh
0771  FF      		db	0ffh
0772  FF      		db	0ffh
0773  FF      		db	0ffh
0774  FF      		db	0ffh
0775  FF      		db	0ffh
0776  FF      		db	0ffh
0777  FF      		db	0ffh
0778  FF      		db	0ffh
0779  FF      		db	0ffh
077A  FF      		db	0ffh
077B  FF      		db	0ffh
077C  FF      		db	0ffh
077D  FF      		db	0ffh
077E  FF      		db	0ffh
077F  FF      		db	0ffh
0780  FF      		db	0ffh
0781  FF      		db	0ffh
0782  FF      		db	0ffh
0783  FF      		db	0ffh
0784  FF      		db	0ffh
0785  FF      		db	0ffh
0786  FF      		db	0ffh
0787  FF      		db	0ffh
0788  FF      		db	0ffh
0789  FF      		db	0ffh
078A  FF      		db	0ffh
078B  FF      		db	0ffh
078C  FF      		db	0ffh
078D  FF      		db	0ffh
078E  FF      		db	0ffh
078F  FF      		db	0ffh
0790  FF      		db	0ffh
0791  FF      		db	0ffh
0792  FF      		db	0ffh
0793  FF      		db	0ffh
0794  FF      		db	0ffh
0795  FF      		db	0ffh
0796  FF      		db	0ffh
0797  FF      		db	0ffh
0798  FF      		db	0ffh
0799  FF      		db	0ffh
079A  FF      		db	0ffh
079B  FF      		db	0ffh
079C  FF      		db	0ffh
079D  FF      		db	0ffh
079E  FF      		db	0ffh
079F  FF      		db	0ffh
07A0  FF      		db	0ffh
07A1  FF      		db	0ffh
07A2  FF      		db	0ffh
07A3  FF      		db	0ffh
07A4  FF      		db	0ffh
07A5  FF      		db	0ffh
07A6  FF      		db	0ffh
07A7  FF      		db	0ffh
07A8  FF      		db	0ffh
07A9  FF      		db	0ffh
07AA  FF      		db	0ffh
07AB  FF      		db	0ffh
07AC  FF      		db	0ffh
07AD  FF      		db	0ffh
07AE  FF      		db	0ffh
07AF  FF      		db	0ffh
07B0  FF      		db	0ffh
07B1  FF      		db	0ffh
07B2  FF      		db	0ffh
07B3  FF      		db	0ffh
07B4  FF      		db	0ffh
07B5  FF      		db	0ffh
07B6  FF      		db	0ffh
07B7  FF      		db	0ffh
07B8  FF      		db	0ffh
07B9  FF      		db	0ffh
07BA  FF      		db	0ffh
07BB  FF      		db	0ffh
07BC  FF      		db	0ffh
07BD  FF      		db	0ffh
07BE  FF      		db	0ffh
07BF  FF      		db	0ffh
07C0  FF      		db	0ffh
07C1  FF      		db	0ffh
07C2  FF      		db	0ffh
07C3  FF      		db	0ffh
07C4  FF      		db	0ffh
07C5  FF      		db	0ffh
07C6  FF      		db	0ffh
07C7  FF      		db	0ffh
07C8  FF      		db	0ffh
07C9  FF      		db	0ffh
07CA  FF      		db	0ffh
07CB  FF      		db	0ffh
07CC  FF      		db	0ffh
07CD  FF      		db	0ffh
07CE  FF      		db	0ffh
07CF  FF      		db	0ffh
07D0  FF      		db	0ffh
07D1  FF      		db	0ffh
07D2  FF      		db	0ffh
07D3  FF      		db	0ffh
07D4  FF      		db	0ffh
07D5  FF      		db	0ffh
07D6  FF      		db	0ffh
07D7  FF      		db	0ffh
07D8  FF      		db	0ffh
07D9  FF      		db	0ffh
07DA  FF      		db	0ffh
07DB  FF      		db	0ffh
07DC  FF      		db	0ffh
07DD  FF      		db	0ffh
07DE  FF      		db	0ffh
07DF  FF      		db	0ffh
07E0  FF      		db	0ffh
07E1  FF      		db	0ffh
07E2  FF      		db	0ffh
07E3  FF      		db	0ffh
07E4  FF      		db	0ffh
07E5  FF      		db	0ffh
07E6  FF      		db	0ffh
07E7  FF      		db	0ffh
07E8  FF      		db	0ffh
07E9  FF      		db	0ffh
07EA  FF      		db	0ffh
07EB  FF      		db	0ffh
07EC  FF      		db	0ffh
07ED  FF      		db	0ffh
07EE  FF      		db	0ffh
07EF  FF      		db	0ffh
07F0  FF      		db	0ffh
07F1  FF      		db	0ffh
07F2  FF      		db	0ffh
07F3  FF      		db	0ffh
07F4  FF      		db	0ffh
07F5  FF      		db	0ffh
07F6  FF      		db	0ffh
07F7  FF      		db	0ffh
07F8  FF      		db	0ffh
07F9  FF      		db	0ffh
07FA  FF      		db	0ffh
07FB  FF      		db	0ffh
07FC  FF      		db	0ffh
07FD  FF      		db	0ffh
07FE  FF      		db	0ffh
07FF  FF      		db	0ffh
		
		; RAM used...
FF00          		org	0ff00h
FF00          	addr0:	ds	2
FF02          	addr1:	ds	2
FF04          	line:	ds	64
		
FF44          		end



Statistics:

     4	passes
     0	jr promotions
   174	symbols
  2048	bytes

   441	macro calls
  3759	macro bytes
     0	invented symbols
