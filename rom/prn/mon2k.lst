		; serial-port ROM monitor/boot for debugging Kaypro.
		; Uses "aux serial" a.k.a "Serial Printer" port.
		
0027          	VERN	equ	027h	; ROM version
		
FFFF          	rom2k	equ	-1
		
FFFF          	 if rom2k
0800          	romsiz	equ	0800h	; space for 2716 ROM
		 else
		 endif
		
			maclib	z80
**** z80.lib ****
**** mon2k.asm ****
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0003          	CTLC	equ	3
0007          	BEL	equ	7
0009          	TAB	equ	9
0008          	BS	equ	8
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
		; WD1943 at 5.0688MHz...
000E          	B9600	equ	0eh
0005          	B300	equ	05h
		; */84 (and 10) sysport drive select
0002          	DS0	equ	0010b
0001          	DS1	equ	0001b
0003          	DSNONE	equ	0011b	; also mask
0010          	K84MTR	equ	00010000b	; */84 (10) MOTOR control, 1=ON
0010          	K83PPS	equ	00010000b	; */83 ParPrt strobe (normally 0)
0040          	K84CCG	equ	01000000b	; */84 (10) CharGen A12
0040          	K83MTR	equ	01000000b	; */83 MOTOR control, 1=OFF
		
0004          	sio1	equ	04h	; "serial data", "keyboard"
000C          	sio2	equ	0ch	; "serial printer", "modem"
0000          	brd1	equ	00h
0008          	brd2	equ	08h
		
0000          	sioA	equ	00h	; offsets
0001          	sioB	equ	01h
		
0000          	sioD	equ	00h	; offsets
0002          	sioC	equ	02h
		
		; Choose Z80SIO port to use...
0004          	condat	equ	sio1+sioA+sioD
0006          	conctl	equ	sio1+sioA+sioC
0000          	conbrr	equ	brd1
		
0005          	kbddat	equ	sio1+sioB+sioD
0007          	kbdctl	equ	sio1+sioB+sioC
000C          	kbdbrr	equ	0ch	; */83 uses WD1943, else hardwired to 300 baud
		
001C          	crtctl	equ	1ch	; */84 and 10 only
001D          	crtdat	equ	1dh	; */84 and 10 only
001F          	crtram	equ	1fh	; also accesses CRTC
		
0014          	sysp84	equ	14h	; sysport on */84 (and 10). */83 have nothing here.
		
0010          	fpysts	equ	10h
0010          	fpycmd	equ	10h
0011          	fpytrk	equ	11h
0012          	fpysec	equ	12h
0013          	fpydat	equ	13h
		
0080          	hdddat	equ	80h
0081          	hdderr	equ	81h
0082          	hddcnt	equ	82h
0083          	hddsec	equ	83h
0084          	hddclo	equ	84h
0085          	hddchi	equ	85h
0086          	hddsdh	equ	86h
0087          	hddcmd	equ	87h
		
0000          	stack	equ	00000h	; stack at top of memory (wrapped)
		
		; Defined entry points:
		; 0003: conout, C=char
		; 000B: hexout, A=value
		; 0013: msgprt, HL=string (NUL)
		; 001B: crlf
		; 0023: (reserved)
		; 002B: (reserved)
		; 0033:	sample I/O port C, initial val B, A=max (returns DE)
		; 003B: dump samples 8000H to DE
		
		; Start of ROM code
0000          		org	00000h
0000  C37000  	reset:	jmp	init
0003  C38F00  		jmp	conout	; 0003: conout, C=char
0006  FFFF    		db	0ffh,0ffh
		
0008  C34B00  	rst1:	jmp	swtrap
000B  C30907  		jmp	hexout	; 000B:
000E  FFFF    		db	0ffh,0ffh
		
0010  C34B00  	rst2:	jmp	swtrap
0013  C32D07  		jmp	msgprt	; 0013:
0016  FFFF    		db	0ffh,0ffh
		
0018  C34B00  	rst3:	jmp	swtrap
001B  C32307  		jmp	crlf	; 001B:
001E  FFFF    		db	0ffh,0ffh
		
0020  C34B00  	rst4:	jmp	swtrap
0023  C34B00  		jmp	swtrap	; 0023:
0026  FFFF    		db	0ffh,0ffh
		
0028  C34B00  	rst5:	jmp	swtrap
002B  C34B00  		jmp	swtrap	; 002B:
002E  FFFF    		db	0ffh,0ffh
		
0030  C34B00  	rst6:	jmp	swtrap
0033  C3B506  		jmp	xsamp1	; 0033: sample a port
0036  FFFF    		db	0ffh,0ffh
		
0038  C34B00  	rst7:	jmp	swtrap
003B  C3E206  		jmp	ysamp	; 003B: dump samples
003E  FFFF    		db	0ffh,0ffh
		
			; NMI needed for FLPY testing
		
0040  0D0A2A2A	swt:	db	CR,LF,'*** RST ',TRM
      2A205253
      542000
		
004B  F3      	swtrap:	di		; try to recover return address...
004C  D1      		pop	d	; should be caller of RST...
004D  310000  		lxi	sp,stack
0050  D5      		push	d	; not needed?
0051  214000  		lxi	h,swt
0054  CD2D07  		call	msgprt
0057  D1      		pop	d
0058  CD0407  		call	taddr
005B  CD2307  		call	crlf
005E  C3E500  		jmp	debug
		
			rept	0066h-$
0061  FF      		db	0ffh
0062  FF      		db	0ffh
0063  FF      		db	0ffh
0064  FF      		db	0ffh
0065  FF      		db	0ffh
0000          	 if $ <> 0066h
		 endif
0066  C9      	nmi:	ret
		
0067  18      	sioini:	db	18h	; reset
0068  0444    		db	4,044h	; 16x, 1s, Np
006A  03C1    		db	3,0c1h	; 8b, RxEn
006C  05EA    		db	5,0eah	; DTR, 8b, TxEn, RTS
006E  0100    		db	1,000h	;
0009          	siolen	equ	$-sioini
		
		; ROM start point - initialize everything
		; We know we have 64K RAM...
0070  F3      	init:	di
0071  310000  		lxi	sp,stack
		
			; init serial port
0074  3E0E    		mvi	a,B9600
0076  D300    		out	conbrr
0078  216700  		lxi	h,sioini
007B  0E06    		mvi	c,conctl
007D  0609    		mvi	b,siolen
007F          		outir
007F  EDB3    		DB	0EDH,0B3H
		
0081  21C500  		lxi	h,signon
0084  CD2D07  		call	msgprt
		
0087  CDDA07  		call	proginit
008A  C3E500  		jmp	debug
		
008D          	belout:
008D  0E07    		mvi	c,BEL
		; Output char to console
		; C=char
008F          	conout:
008F  DB06    		in	conctl
0091  E604    		ani	00000100b
0093          		jrz	conout
0093  28FA    		DB	28H,conout-$-1
0095  79      		mov	a,c
0096  D304    		out	condat
0098  C9      		ret
		
0099  0D0A3A20	prompt:	db	CR,LF,': ',TRM
      00
		
		; Get char from console
		; Returns: A=char, stripped
009E  E5      	conin:	push	h
009F  210000  	ci2:	lxi	h,0
00A2  DB06    	ci0:	in	conctl		; 11
00A4  E601    		ani	00000001b	;  7
00A6          		jrnz	ci1		;  7
00A6  200A    		DB	20H,ci1-$-1
00A8  2B      		dcx	h		;  6
00A9  7D      		mov	a,l		;  4
00AA  B4      		ora	h		;  4
00AB          		jrnz	ci0		; 12 = 51 (12.75uS) (~0.8 sec)
00AB  20F5    		DB	20H,ci0-$-1
00AD  CDEE07  		call	progress	; on */83 (20.4uS or ~1.3 sec)
00B0          		jr	ci2
00B0  18ED    		DB	18H,ci2-$-1
00B2  DB04    	ci1:	in	condat
00B4  E67F    		ani	07fh
00B6  E1      		pop	h
00B7  C9      		ret
		
		; Get char from console, toupper and echo
00B8          	conine:
00B8  CD9E00  		call	conin
00BB  CD3D07  		call	toupper
00BE  F5      		push	psw
00BF  4F      		mov	c,a
00C0  CD8F00  		call	conout
00C3  F1      		pop	psw
00C4  C9      		ret
		
00C5  0D0A4B61	signon:	db	CR,LF,'Kaypro'
      7970726F
FFFF          	 if rom2k
00CD  2D4949  		db	'-II'
		 endif
00D0  204D6F6E		db	' Monitor v'
      69746F72
      2076
00DA  322E37  	vernum:	db	(VERN SHR 4)+'0','.',(VERN AND 0fh)+'0'
00DD  0D0A00  		db	CR,LF,TRM
		
00E0  0D0A073F	errm:	db	CR,LF,BEL,'?',TRM
      00
		
		*********************************************************
		**  Debug mode
		*********************************************************
		
00E5          	debug:
00E5  310000  	cilp:	lxi	sp,stack
00E8  21E500  		lxi	h,cilp		;setup return address
00EB  E5      		push	h
00EC  219900  		lxi	h,prompt	;prompt for a command
00EF  CD2D07  		call	msgprt
00F2  CD4607  		call	linein		;wait for command line to be entered
00F5  CDE307  		call	progoff		; turn off progress indicators
00F8  1104FF  		lxi	d,line
00FB  CD9407  		call	char		;get first character
00FE  C8      		rz			;ignore line if it is empty
00FF  211901  		lxi	h,comnds	;search table for command character
0102  060C    		mvi	b,ncmnds	;(number of commands)
0104  BE      	cci0:	cmp	m		;search command table
0105  23      		inx	h
0106          		jrz	gotocmd		;command was found, execute it
0106  280A    		DB	28H,gotocmd-$-1
0108  23      		inx	h		;step past routine address
0109  23      		inx	h
010A          		djnz	cci0		;loop untill all valid commands are checked
010A  10F8    		DB	10H,cci0-$-1
010C  21E000  	error:	lxi	h,errm		;if command unknown, beep and re-prompt
010F  C32D07  		jmp	msgprt
		
0112          	gotocmd:
0112  D5      		push	d		;save command line buffer pointer
0113  5E      		mov	e,m		;get command routine address
0114  23      		inx	h
0115  56      		mov	d,m		;DE = routine address
0116  EB      		xchg			;HL = routine address
0117  D1      		pop	d		;restore buffer pointer
0118  E9      		pchl			;jump to command routine
		
		; All commands are started with DE=next char in line buffer
0119          	comnds:
0119  3F      		db	'?'
011A  FC02    		dw	Qcomnd
011C  44      		db	'D'
011D  A403    		dw	Dcomnd
011F  53      		db	'S'
0120  0A04    		dw	Scomnd
0122  47      		db	'G'
0123  7204    		dw	Gcomnd
0125  4D      		db	'M'
0126  0303    		dw	Mcomnd
0128  46      		db	'F'
0129  6403    		dw	Fcomnd
012B  49      		db	'I'
012C  AD04    		dw	Icomnd
012E  4F      		db	'O'
012F  FF04    		dw	Ocomnd
0131  48      		db	'H'
0132  6F06    		dw	Hcomnd
0134  4E      		db	'N'
0135  3405    		dw	Ncomnd
0137  54      		db	'T'
0138  7B05    		dw	Tcomnd
013A  56      		db	'V'
013B  4F06    		dw	Vcomnd
000C          	ncmnds	equ	($-comnds)/3
		
		*********************************************************
		**  Command subroutines
		*********************************************************
		
013D          	menu:
013D  0D0A4420		db	CR,LF,'D <start> <end> - display memory in HEX'
      3C737461
      72743E20
      3C656E64
      3E202D20
      64697370
      6C617920
      6D656D6F
      72792069
      6E204845
      58
0166  0D0A5320		db	CR,LF,'S <start> - set/view memory'
      3C737461
      72743E20
      2D207365
      742F7669
      6577206D
      656D6F72
      79
0183  0D0A2020		db	CR,LF,'    (CR) = skip fwd, ''-'' = skip bkwd, ''.'' = done'
      20202843
      5229203D
      20736B69
      70206677
      642C2027
      2D27203D
      20736B69
      7020626B
      77642C20
      272E2720
      3D20646F
      6E65
01B5  0D0A4720		db	CR,LF,'G <start> - go to address'
      3C737461
      72743E20
      2D20676F
      20746F20
      61646472
      657373
01D0  0D0A4620		db	CR,LF,'F <start> <end> <data> - fill memory'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6174613E
      202D2066
      696C6C20
      6D656D6F
      7279
01F6  0D0A4D20		db	CR,LF,'M <start> <end> <dest> - Move data'
      3C737461
      72743E20
      3C656E64
      3E203C64
      6573743E
      202D204D
      6F766520
      64617461
021A  0D0A4920		db	CR,LF,'I <port> [num] - Input from port'
      3C706F72
      743E205B
      6E756D5D
      202D2049
      6E707574
      2066726F
      6D20706F
      7274
023C  0D0A4F20		db	CR,LF,'O <port> <value> [...] - Output to port'
      3C706F72
      743E203C
      76616C75
      653E205B
      2E2E2E5D
      202D204F
      75747075
      7420746F
      20706F72
      74
0265  0D0A4820		db	CR,LF,'H - Hexload program'
      2D204865
      786C6F61
      64207072
      6F677261
      6D
027A  0D0A4E20		db	CR,LF,'N <hw> - iNitialize hardware (KB83'
      3C68773E
      202D2069
      4E697469
      616C697A
      65206861
      72647761
      72652028
      4B423833
0000          	 if not rom2k
		 endif
029E  29      		db		')'
029F  0D0A5420		db	CR,LF,'T <hw> - Test hardware'
      3C68773E
      202D2054
      65737420
      68617264
      77617265
02B7  0D0A2020		db	CR,LF,'  (KBD'
      284B4244
0000          	 if not rom2k
		 endif
02BF  2C204644		db		', FDRD, FLPY)'
      52442C20
      464C5059
      29
02CC  0D0A5620		db	CR,LF,'V - Show ROM version'
      2D205368
      6F772052
      4F4D2076
      65727369
      6F6E
02E2  0D0A5E43		db	CR,LF,'^C aborts command entry'
      2061626F
      72747320
      636F6D6D
      616E6420
      656E7472
      79
02FB  00      		db	TRM
		
02FC          	Qcomnd:
02FC  213D01  		lxi	h,menu
02FF  CD2D07  		call	msgprt
0302  C9      		ret
		
0303  CDA007  	Mcomnd:	call	getaddr
0306  DA0C01  		jc	error
0309          		bit	7,b
0309  CB78    		DB	0CBH,7*8+b+40H
030B  C20C01  		jnz	error
030E  2200FF  		shld	addr0
0311  CDA007  		call	getaddr
0314  DA0C01  		jc	error
0317          		bit	7,b
0317  CB78    		DB	0CBH,7*8+b+40H
0319  C20C01  		jnz	error
031C  2202FF  		shld	addr1
031F  CDA007  		call	getaddr
0322  DA0C01  		jc	error
0325          		bit	7,b
0325  CB78    		DB	0CBH,7*8+b+40H
0327  C20C01  		jnz	error
032A  EB      		xchg
032B          		lbcd	addr0
032B  ED4B    		DB	0EDH,4BH
032D  00FF    		DW	addr0
032F  2A02FF  		lhld	addr1
0332  B7      		ora	a
0333          		dsbc	b
0333  ED42    		DB	0EDH,b*8+42H
0335  DA0C01  		jc	error
0338  23      		inx	h
0339  4D      		mov	c,l
033A  44      		mov	b,h
033B  D5      		push	d
033C  EB      		xchg
033D  09      		dad	b
033E  D1      		pop	d
033F  DA0C01  		jc	error
0342  2A02FF  		lhld	addr1
0345  CD3707  		call	check
0348  DA5E03  		jc	mc0
034B  2A00FF  		lhld	addr0
034E  CD3707  		call	check
0351  D25E03  		jnc	mc0
0354  2A02FF  		lhld	addr1
0357  EB      		xchg
0358  09      		dad	b
0359  2B      		dcx	h
035A  EB      		xchg
035B          		lddr
035B  EDB8    		DB	0EDH,0B8H
035D  C9      		ret
035E  2A00FF  	mc0:	lhld	addr0
0361          		ldir
0361  EDB0    		DB	0EDH,0B0H
0363  C9      		ret
0364          	Fcomnd:
0364  CDA007  		call	getaddr ;get address to start at
0367  DA0C01  		jc	error	;error if non-hex character
036A          		bit	7,b	;test for no address (different from 0000)
036A  CB78    		DB	0CBH,7*8+b+40H
036C  C20C01  		jnz	error	;error if no address was entered
036F  2200FF  		shld	addr0	;save starting address
0372  CDA007  		call	getaddr ;get stop address
0375  DA0C01  		jc	error	;error if non-hex character
0378          		bit	7,b	;test for no entry
0378  CB78    		DB	0CBH,7*8+b+40H
037A  C20C01  		jnz	error	;error if no stop address
037D  2202FF  		shld	addr1	;save stop address
0380  CDA007  		call	getaddr ;get fill data
0383  DA0C01  		jc	error	;error if non-hex character
0386          		bit	7,b	;test for no entry
0386  CB78    		DB	0CBH,7*8+b+40H
0388  C20C01  		jnz	error	;error if no fill data
038B  7C      		mov	a,h
038C  B7      		ora	a
038D  C20C01  		jnz	error
0390  4D      		mov	c,l	;(C)=fill data
0391  2A02FF  		lhld	addr1	;get stop address
0394          		lded	addr0	;get start address
0394  ED5B    		DB	0EDH,5BH
0396  00FF    		DW	addr0
0398  79      	fc0:	mov	a,c	;
0399  12      		stax	d	;put byte in memory
039A  13      		inx	d	;step to next byte
039B  7A      		mov	a,d	;
039C  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
039D  C8      		rz		;
039E  CD3707  		call	check	;test for past stop address
03A1  D8      		rc	;quit if past stop address
03A2          		jr	fc0
03A2  18F4    		DB	18H,fc0-$-1
		
03A4          	Dcomnd:		;display memory
03A4  CDA007  		call	getaddr ;get address to start at
03A7  DA0C01  		jc	error	;error if non-hex character
03AA          		bit	7,b	;test for no address (different from 0000)
03AA  CB78    		DB	0CBH,7*8+b+40H
03AC  C20C01  		jnz	error	;error if no address was entered
03AF  2200FF  		shld	addr0	;save starting address
03B2  CDA007  		call	getaddr ;get stop address
03B5  DA0C01  		jc	error	;error if non-hex character
03B8          		bit	7,b	;test for no entry
03B8  CB78    		DB	0CBH,7*8+b+40H
03BA  C20C01  		jnz	error	;error if no stop address
03BD          		lded	addr0	;get start address into (DE)
03BD  ED5B    		DB	0EDH,5BH
03BF  00FF    		DW	addr0
03C1  CD2307  	dis0:	call	crlf	;start on new line
03C4  CD0407  		call	taddr	;print current address
03C7  CD1E07  		call	space	;delimit it from data
03CA  0610    		mvi	b,16	;display 16 bytes on each line
03CC  1A      	dis1:	ldax	d	;get byte to display
03CD  13      		inx	d	;step to next byte
03CE  CD0907  		call	hexout	;display this byte in HEX
03D1  CD1E07  		call	space	;delimit it from others
03D4  7A      		mov	a,d
03D5  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03D6          		jrz	dis2
03D6  2807    		DB	28H,dis2-$-1
03D8  CD3707  		call	check	;test for past stop address
03DB          		jrc	dis2	;quit if past stop address
03DB  3802    		DB	38H,dis2-$-1
03DD          		djnz	dis1	;else do next byte on this line
03DD  10ED    		DB	10H,dis1-$-1
03DF  CD1E07  	dis2:	call	space	;delimit it from data
03E2  CD1E07  		call	space
03E5          		lded	addr0
03E5  ED5B    		DB	0EDH,5BH
03E7  00FF    		DW	addr0
03E9  0610    		mvi	b,16	;display 16 bytes on each line
03EB  1A      	dis3:	ldax	d	;get byte to display
03EC  13      		inx	d	;step to next byte
03ED  0E2E    		mvi	c,'.'
03EF  FE20    		cpi	' '
03F1          		jrc	dis4
03F1  3805    		DB	38H,dis4-$-1
03F3  FE7F    		cpi	'~'+1
03F5          		jrnc	dis4
03F5  3001    		DB	30H,dis4-$-1
03F7  4F      		mov	c,a
03F8  CD8F00  	dis4:	call	conout
03FB  7A      		mov	a,d
03FC  B3      		ora	e	;if we reach 0000, stop. (don't wrap around)
03FD  C8      		rz
03FE  CD3707  		call	check	;test for past stop address
0401  D8      		rc	;quit if past stop address
0402          		djnz	dis3	;else do next byte on this line
0402  10E7    		DB	10H,dis3-$-1
0404          		sded	addr0
0404  ED53    		DB	0EDH,53H
0406  00FF    		DW	addr0
0408          		jr	dis0	;when line is finished, start another
0408  18B7    		DB	18H,dis0-$-1
		
040A          	Scomnd: 		;substitute (set) memory
040A  CDA007  		call	getaddr ;get address to start substitution at
040D  DA0C01  		jc	error	;error if non-hex character
0410          		bit	7,b	;test for no entry
0410  CB78    		DB	0CBH,7*8+b+40H
0412  C20C01  		jnz	error	;error if no address
0415  EB      		xchg		;put address in (DE)
0416  CD2307  	sb1:	call	crlf	;start on new line
0419  CD0407  		call	taddr	;print address
041C  CD1E07  		call	space	;and delimit it
041F  1A      		ldax	d	;get current value of byte
0420  CD0907  		call	hexout	;and display it
0423  CD1E07  		call	space	;delimit it from user's (posible) entry
0426  0600    		mvi	b,0	;zero accumilator for user's entry
0428  CDB800  	sb2:	call	conine	;get user's first character
042B  FE0D    		cpi	CR	;if CR then skip to next byte
042D          		jrz	foward
042D  2833    		DB	28H,foward-$-1
042F  FE20    		cpi	' '	;or if Space then skip to next
0431          		jrz	foward
0431  282F    		DB	28H,foward-$-1
0433  FE2D    		cpi	'-'	;if Minus then step back to previous address
0435          		jrz	bakwrd
0435  282E    		DB	28H,bakwrd-$-1
0437  FE2E    		cpi	'.'	;if Period then stop substitution
0439  C8      		rz
043A  CDC707  		call	hexcon	;if none of the above, should be HEX digit
043D          		jrc	error0	;error if not
043D  3829    		DB	38H,error0-$-1
043F          		jr	sb3	;start accumilating HEX digits
043F  1805    		DB	18H,sb3-$-1
0441  CDC707  	sb0:	call	hexcon	;test for HEX digit
0444          		jrc	error1	;error if not HEX
0444  3827    		DB	38H,error1-$-1
0446          	sb3:	slar	b	;roll accumilator to receive new digit
0446  CB20    		DB	0CBH, 20H + b
0448          		slar	b
0448  CB20    		DB	0CBH, 20H + b
044A          		slar	b
044A  CB20    		DB	0CBH, 20H + b
044C          		slar	b
044C  CB20    		DB	0CBH, 20H + b
044E  B0      		ora	b	;merge in new digit
044F  47      		mov	b,a
0450  CDB800  	sb4:	call	conine	;get next character
0453  FE0D    		cpi	CR	;if CR then put existing byte into memory
0455          		jrz	putbyte ;  and step to next.
0455  2809    		DB	28H,putbyte-$-1
0457  FE2E    		cpi	'.'
0459  C8      		rz
045A  FE7F    		cpi	del	;if DEL then restart at same address
045C          		jrz	sb1
045C  28B8    		DB	28H,sb1-$-1
045E          		jr	sb0	;else continue entering hex digits
045E  18E1    		DB	18H,sb0-$-1
0460          	putbyte:
0460  78      		mov	a,b	;store accumilated byte in memory
0461  12      		stax	d
0462          	foward:
0462  13      		inx	d	;step to next location
0463          		jr	sb1	;and allow substitution there
0463  18B1    		DB	18H,sb1-$-1
		
0465          	bakwrd:
0465  1B      		dcx	d	;move address backward one location
0466          		jr	sb1
0466  18AE    		DB	18H,sb1-$-1
		
0468  CD8D00  	error0:	call	belout	;user's entry was not valid, beep and continue
046B          		jr	sb2
046B  18BB    		DB	18H,sb2-$-1
046D  CD8D00  	error1:	call	belout	;same as above but for different section of routine
0470          		jr	sb4
0470  18DE    		DB	18H,sb4-$-1
		
0472          	Gcomnd: 		;jump to address given by user
0472  CDA007  		call	getaddr ;get address to jump to
0475  DA0C01  		jc	error	;error if non-hex character
0478          		bit	7,b	;test for no entry
0478  CB78    		DB	0CBH,7*8+b+40H
047A  C20C01  		jnz	error	;error if no address entered
047D  CD2307  		call	crlf	;on new line,
0480  0E47    		mvi	c,'G'	;display "GO aaaa?" to ask
0482  CD8F00  		call	conout	;user to verify that we should
0485  0E4F    		mvi	c,'O'	;jump to this address (in case user
0487  CD8F00  		call	conout	;made a mistake we should not blindly
048A  CD1E07  		call	space	;commit suicide)
048D  EB      		xchg
048E  CD0407  		call	taddr
0491  CD1E07  		call	space
0494  0E3F    		mvi	c,'?'
0496  CD8F00  		call	conout
0499  CDB800  		call	conine	;wait for user to type "Y" to
049C  FE59    		cpi	'Y'	;indicate that we should jump.
049E  C0      		rnz		;abort if response was not "Y"
049F  CD2307  		call	crlf	; visual feedback
04A2  EB      		xchg
04A3  E9      		pchl		;else jump to address
		
04A4  0D0A496E	inpms:	db	CR,LF,'Input ',TRM
      70757420
      00
04AD          	Icomnd:
04AD  CDA007  		call	getaddr ;get port address, ignore extra MSDs
04B0  DA0C01  		jc	error	;error if non-hex character
04B3          		bit	7,b	;test for no entry
04B3  CB78    		DB	0CBH,7*8+b+40H
04B5  C20C01  		jnz	error	;error if no address entered
04B8  E5      		push	h	; save port
04B9  CDA007  		call	getaddr	; hex number of inputs to do
04BC  DA0C01  		jc	error
04BF          		bit	7,b
04BF  CB78    		DB	0CBH,7*8+b+40H
04C1          		jrz	ic0
04C1  2803    		DB	28H,ic0-$-1
04C3  210100  		lxi	h,1
04C6          	ic0:
04C6  E3      		xthl		; save count
04C7  E5      		push	h	; re-save port
04C8  21A404  		lxi	h,inpms
04CB  CD2D07  		call	msgprt
04CE  E1      		pop	h
04CF  E5      		push	h
04D0  7D      		mov	a,l
04D1  CD0907  		call	hexout
04D4  CD1E07  		call	space
04D7  0E3D    		mvi	c,'='
04D9  CD8F00  		call	conout
			; "Input XX ="
04DC  C1      		pop	b	; port to BC
04DD  E1      		pop	h	; count to HL (L)
04DE  260D    		mvi	h,16-3
04E0  0600    		mvi	b,0	; safety
04E2  C5      		push	b	; C gets trashed by conout
04E3          	ic1:
04E3  CD1E07  		call	space
04E6  C1      		pop	b
04E7  C5      		push	b
04E8          		inp	a
04E8  ED78    		DB	0EDH,a*8+40H
04EA  CD0907  		call	hexout
04ED  2D      		dcr	l	; assume <= 256
04EE          		jrz	ic2
04EE  280A    		DB	28H,ic2-$-1
04F0  25      		dcr	h	; col count
04F1          		jrnz	ic1
04F1  20F0    		DB	20H,ic1-$-1
04F3  CD2307  		call	crlf
04F6  2610    		mvi	h,16
04F8          		jr	ic1
04F8  18E9    		DB	18H,ic1-$-1
04FA          	ic2:
04FA  C1      		pop	b	; fix stack
04FB  CD2307  		call	crlf
04FE  C9      		ret
		
		; TODO: no feedback?
04FF          	Ocomnd:
04FF  CDA007  		call	getaddr ;get port address, ignore extra MSDs
0502  DA0C01  		jc	error	;error if non-hex character
0505          		bit	7,b	;test for no entry
0505  CB78    		DB	0CBH,7*8+b+40H
0507  C20C01  		jnz	error	;error if no address entered
050A  2600    		mvi	h,0	; safety
050C  E5      		push	h	; save port
050D  CDA007  		call	getaddr ;get value, ignore extra MSDs
0510  DA0C01  		jc	error	;error if non-hex character
0513          		bit	7,b	;test for no entry
0513  CB78    		DB	0CBH,7*8+b+40H
0515  C20C01  		jnz	error	;error if no value entered
0518  CD2307  		call	crlf
051B          	oc0:		; L has byte to output...
051B  C1      		pop	b	; port
051C  C5      		push	b
051D          		outp	l
051D  ED69    		DB	0EDH,l*8+41H
051F  CDA007  		call	getaddr ;get value, ignore extra MSDs
0522  DA0C01  		jc	error	;error if non-hex character
					;NOTE: some output has been sent
0525          		bit	7,b	;test for no entry
0525  CB78    		DB	0CBH,7*8+b+40H
0527          		jrz	oc0	;still more to send
0527  28F2    		DB	28H,oc0-$-1
0529  E1      		pop	h	; discard port
052A  C9      		ret
		
052B  CD9407  	skb:	call	char
052E  C8      		rz		;end of buffer/line before a character was found (ZR)
052F  FE20    		cpi	' '	;skip all leading spaces
0531  C0      		rnz		;if not space, then done (NZ)
0532          		jr	skb	;else if space, loop untill not space
0532  18F7    		DB	18H,skb-$-1
		
0534          	Ncomnd:
0534  CD2B05  		call	skb	; skip blanks
0537  CA0C01  		jz	error	; required param
			; this may need refinement
053A  1B      		dcx	d
053B  214605  		lxi	h,kb83
053E  CD6705  		call	strcmp
0541          		jrz	nkb83
0541  2816    		DB	28H,nkb83-$-1
0000          	 if not rom2k
		 endif
0543  C30C01  		jmp	error
		
0546  4B423833	kb83:	db	'KB83',TRM
      00
0000          	 if not rom2k
		 endif
054B  46445244	fdrd:	db	'FDRD',TRM
      00
0550  464C5059	flpy:	db	'FLPY',TRM
      00
0555  4B424400	kbd:	db	'KBD',TRM
		
0559  3E05    	nkb83:	mvi	a,B300
055B  D30C    		out	kbdbrr	; */83 baud gen for SIO1 ch B
055D  216700  	nkb84:	lxi	h,sioini
0560  0E07    		mvi	c,kbdctl
0562  0609    		mvi	b,siolen
0564          		outir
0564  EDB3    		DB	0EDH,0B3H
0566  C9      		ret
		
0000          	 if not rom2k
		 endif
		
		; if match, return DE after last match.
		; if no match, return original DE.
0567  D5      	strcmp:	push	d
0568  AF      		xra	a
0569  BE      	sc0:	cmp	m	; TRM?
056A          		jrz	sc9	; A = 0
056A  2808    		DB	28H,sc9-$-1
056C  1A      		ldax	d
056D  96      		sub	m
056E          		jrnz	sc8	; A is NZ
056E  2008    		DB	20H,sc8-$-1
0570  23      		inx	h
0571  13      		inx	d
0572          		jr	sc0
0572  18F5    		DB	18H,sc0-$-1
0574  33      	sc9:	inx	sp	; non-destructive POP
0575  33      		inx	sp
0576  AF      		xra	a	; A=0 and ZR
0577  C9      		ret
0578  D1      	sc8:	pop	d	; restore orig location
0579  B7      		ora	a
057A  C9      		ret
		
057B          	Tcomnd:
057B  CD2B05  		call	skb	; skip blanks
057E  CA0C01  		jz	error	; required param
			; this may need refinement
0581  1B      		dcx	d
0582  215505  		lxi	h,kbd
0585  CD6705  		call	strcmp
0588  CAA005  		jz	tkbd
0000          	 if not rom2k
		 endif
058B  214B05  		lxi	h,fdrd
058E  CD6705  		call	strcmp
0591  CAD605  		jz	tfdrd
0594  215005  		lxi	h,flpy
0597  CD6705  		call	strcmp
059A  CA0F06  		jz	tflpy
059D  C30C01  		jmp	error
		
0000          	 if not rom2k
		 endif
		
05A0  21C505  	tkbd:	lxi	h,waitm
05A3  CD2D07  		call	msgprt
05A6  DB07    	tk0:	in	kbdctl
05A8  E601    		ani	00000001b
05AA          		jrnz	tk1
05AA  200F    		DB	20H,tk1-$-1
05AC  DB06    		in	conctl
05AE  E601    		ani	00000001b
05B0          		jrz	tk0
05B0  28F4    		DB	28H,tk0-$-1
05B2  DB04    		in	condat
05B4  21D005  		lxi	h,abrtm
05B7  CD2D07  		call	msgprt
05BA  C9      		ret
05BB  DB05    	tk1:	in	kbddat
05BD  CD0907  		call	hexout
05C0  CD1E07  		call	space
05C3          		jr	tk0
05C3  18E1    		DB	18H,tk0-$-1
		
05C5  0D0A5761	waitm:	db	CR,LF,'Wait... ',TRM
      69742E2E
      2E2000
05D0  41626F72	abrtm:	db	'Abort',TRM
      7400
0000          	 if not rom2k
		 endif
		
		; read a sector from the floppy.
		; user must turn on motors, select drive,
		; set side, set DDEN, and step to track.
		; data stored in 8000h
05D6  AF      	tfdrd:	xra	a
05D7  3200FF  		sta	addr0
05DA  CDA007  		call	getaddr ;get optional sector
05DD  DA0C01  		jc	error	;error if non-hex character
05E0          		bit	7,b	;test for no entry
05E0  CB78    		DB	0CBH,7*8+b+40H
05E2          		jrnz	tfrX
05E2  2008    		DB	20H,tfrX-$-1
05E4  7C      		mov	a,h
05E5  B7      		ora	a
05E6  C20C01  		jnz	error
05E9  2200FF  		shld	addr0	; allow some rediculous values
05EC          	tfrX:			; (also, side 1 uses: 0A..13)
05EC  CD2307  		call	crlf
05EF  3A00FF  		lda	addr0
05F2  D312    		out	fpysec
05F4  210080  		lxi	h,8000h
05F7  011300  		lxi	b,fpydat	; B=0
05FA  3E88    		mvi	a,88h	; read sector, side compare(?)
05FC  D310    		out	fpycmd
05FE  76      	tfr0:	hlt
05FF          		ini
05FF  EDA2    		DB	0EDH,0A2H
0601          		jrnz	tfr0
0601  20FB    		DB	20H,tfr0-$-1
0603  76      	tfr1:	hlt
0604          		ini
0604  EDA2    		DB	0EDH,0A2H
0606          		jrnz	tfr1
0606  20FB    		DB	20H,tfr1-$-1
0608  76      		hlt	; wait for done
0609  DB10    		in	fpysts
060B  CD0907  		call	hexout
060E  C9      		ret
		
060F          	tflpy:	; user must motor on and select drive (and side)
060F  3ED0    		mvi	a,0d0h
0611  3200FF  		sta	addr0	; default: force intr
0614  AF      		xra	a
0615  3202FF  		sta	addr1	; default: 256 samples
0618  CDA007  		call	getaddr ;get optional command
061B  DA0C01  		jc	error	;error if non-hex character
061E          		bit	7,b	;test for no entry
061E  CB78    		DB	0CBH,7*8+b+40H
0620          		jrnz	tfX
0620  201B    		DB	20H,tfX-$-1
0622  7C      		mov	a,h
0623  B7      		ora	a
0624  C20C01  		jnz	error
0627  2200FF  		shld	addr0	;save command
062A  CDA007  		call	getaddr ;get sample count
062D  DA0C01  		jc	error	;error if non-hex character
0630          		bit	7,b	;test for no entry
0630  CB78    		DB	0CBH,7*8+b+40H
0632  C23D06  		jnz	tfX
0635  7C      		mov	a,h
0636  B7      		ora	a
0637  C20C01  		jnz	error
063A  2202FF  		shld	addr1	;save count
063D          	tfX:
063D  CD2307  		call	crlf
0640  0E10    		mvi	c,fpysts
0642          		inp	b
0642  ED40    		DB	0EDH,b*8+40H
0644  3A00FF  		lda	addr0	; FDC command
0647  D310    		out	fpycmd
0649  CDB806  		call	xsamp	; gather samples
064C  C3E206  		jmp	ysamp	; dump samples
		
064F          	Vcomnd:
064F  21C500  		lxi	h,signon
0652  C32D07  		jmp	msgprt
		
		; B = checksum
0655          	getbyte:
0655  CDB800  		call	conine	; trashes C
0658  CDC707  		call	hexcon
065B  D8      		rc
065C  07      		rlc
065D  07      		rlc
065E  07      		rlc
065F  07      		rlc
0660  5F      		mov	e,a
0661  CDB800  		call	conine	; trashes C
0664  CDC707  		call	hexcon
0667  D8      		rc
0668  B3      		ora	e
			; update checksum...
0669  5F      		mov	e,a
066A  80      		add	b
066B  47      		mov	b,a
066C  7B      		mov	a,e
066D  B7      		ora	a
066E  C9      		ret
		
		; Uses:
		;	E' = error indicator (used?)
		;	E = scratch (getbyte)
		;	D = count (per line)
		;	B = checksum (per line)
		;	C = scratch (conine)
		;	HL = dest (per line)
066F          	Hcomnd:
			; TODO: clear error flag
066F  CD2307  	hc2:	call	crlf
0672  CDB800  	hc0:	call	conine
0675  FE03    		cpi	CTLC
0677  C8      		rz
0678  FE3A    		cpi	':'	; start of record
067A          		jrnz	hc0
067A  20F6    		DB	20H,hc0-$-1
067C  0600    		mvi	b,0	; init checksum 0
067E  CD5506  		call	getbyte	; count
0681          		jrc	hc8
0681  382B    		DB	38H,hc8-$-1
0683  57      		mov	d,a
0684          		exaf	; save copy of count
0684  08      		DB	08H
0685  CD5506  		call	getbyte	; addr hi
0688          		jrc	hc8
0688  3824    		DB	38H,hc8-$-1
068A  67      		mov	h,a
068B  CD5506  		call	getbyte	; addr lo
068E          		jrc	hc8
068E  381E    		DB	38H,hc8-$-1
0690  6F      		mov	l,a
0691  CD5506  		call	getbyte	; record type (ignored)
0694          		jrc	hc8
0694  3818    		DB	38H,hc8-$-1
0696  14      		inr	d	; +1 for checksum byte
			; TODO: range check HL... ?
0697  CD5506  	hc1:	call	getbyte
069A          		jrc	hc8
069A  3812    		DB	38H,hc8-$-1
069C  15      		dcr	d
069D          		jrz	hc7
069D  2804    		DB	28H,hc7-$-1
069F  77      		mov	m,a
06A0  23      		inx	h
06A1          		jr	hc1
06A1  18F4    		DB	18H,hc1-$-1
06A3  78      	hc7:	mov	a,b
06A4  B7      		ora	a
06A5          		jrnz	hc8
06A5  2007    		DB	20H,hc8-$-1
06A7          		exaf
06A7  08      		DB	08H
06A8  B7      		ora	a
06A9          		jrnz	hc2
06A9  20C4    		DB	20H,hc2-$-1
			; TODO: what to do with entry addr?
			; TODO: check error flag
06AB  C32307  		jmp	crlf
06AE          	hc8:	; TODO: set error flag
06AE  0E21    		mvi	c,'!'
06B0  CD8F00  		call	conout
06B3          		jr	hc0
06B3  18BD    		DB	18H,hc0-$-1
		
		*********************************************************
		**  Utility subroutines
		*********************************************************
		
		; take samples from port C, storing changes in 8000H
		; B = initial value of port (may be faked).
		; samples are 3 bytes each, new port value and 16-bit iteration count.
		; returns DE pointing +1 after last sample.
06B5  3202FF  	xsamp1:	sta	addr1
		; addr1 = max num samples (0=256)
06B8          	xsamp:
06B8  210000  		lxi	h,0
06BB  110080  		lxi	d,8000h
06BE          	xs0:	inp	a	; 12
06BE  ED78    		DB	0EDH,a*8+40H
06C0  B8      		cmp	b	;  4
06C1          		jrnz	xs4	;  7
06C1  200C    		DB	20H,xs4-$-1
06C3  23      	xs5:	inx	h	;  6
06C4  7C      		mov	a,h	;  4
06C5  B5      		ora	l	;  4
06C6          		jrnz	xs0	; 12 = 49 = 12.25uS (19.6uS)
06C6  20F6    		DB	20H,xs0-$-1
06C8  2B      		dcx	h	; show as FFFF
06C9  3E01    		mvi	a,1
06CB  3202FF  		sta	addr1	; force last sample
06CE  78      		mov	a,b	; current register value
06CF  EB      	xs4:	xchg		;  4
06D0  77      		mov	m,a	;  7
06D1  23      		inx	h	;  6
06D2  73      		mov	m,e	;  7
06D3  23      		inx	h	;  6
06D4  72      		mov	m,d	;  7
06D5  23      		inx	h	;  6
06D6  EB      		xchg		;  4
06D7  47      		mov	b,a	;  4
06D8  3A02FF  		lda	addr1	; 13
06DB  3D      		dcr	a	;  4
06DC  3202FF  		sta	addr1	; 13
06DF          		jrnz	xs5	; 12 = 93 = 23.25uS (37.2uS)
06DF  20E2    		DB	20H,xs5-$-1
06E1  C9      		ret
		
		; print out samples from 8000h to DE
06E2          	ysamp:
06E2  210080  		lxi	h,8000h
06E5  7C      	ys2:	mov	a,h
06E6  BA      		cmp	d
06E7          		jrnz	ys3
06E7  2003    		DB	20H,ys3-$-1
06E9  7D      		mov	a,l
06EA  BB      		cmp	e
06EB  C8      		rz
06EC  7E      	ys3:	mov	a,m
06ED  23      		inx	h
06EE  CD0907  		call	hexout
06F1  CD1E07  		call	space
06F4  46      		mov	b,m
06F5  23      		inx	h
06F6  7E      		mov	a,m
06F7  23      		inx	h
06F8  CD0907  		call	hexout
06FB  78      		mov	a,b
06FC  CD0907  		call	hexout
06FF  CD2307  		call	crlf
0702          		jr	ys2
0702  18E1    		DB	18H,ys2-$-1
		
0704  7A      	taddr:	mov	a,d	;display (DE) at console in HEX
0705  CD0907  		call	hexout	;print HI byte in HEX
0708  7B      		mov	a,e	;now do LO byte
0709  F5      	hexout:	push	psw	;output (A) to console in HEX
070A  07      		rlc		;get HI digit in usable (LO) position
070B  07      		rlc
070C  07      		rlc
070D  07      		rlc
070E  CD1207  		call	nible	;and display it
0711  F1      		pop	psw	;get LO digit back and display it
0712  E60F    	nible:	ani	00001111b	;display LO 4 bits of (A) in HEX
0714  C690    		adi	90h	;algorithm to convert 4-bits to ASCII
0716  27      		daa
0717  CE40    		aci	40h
0719  27      		daa
071A  4F      		mov	c,a	;display ASCII digit
071B  C38F00  		jmp	conout
		
071E  0E20    	space:	mvi	c,' '	;send an ASCII blank to console
0720  C38F00  		jmp	conout
		
0723  0E0D    	crlf:	mvi	c,CR	;send Carriage-Return/Line-Feed to console
0725  CD8F00  		call	conout
0728  0E0A    		mvi	c,LF
072A  C38F00  		jmp	conout
		
072D  7E      	msgprt:	mov	a,m	;send string to console, terminated by 00
072E  B7      		ora	a
072F  C8      		rz
0730  4F      		mov	c,a
0731  CD8F00  		call	conout
0734  23      		inx	h
0735          		jr	msgprt
0735  18F6    		DB	18H,msgprt-$-1
		
0737  E5      	check:	push	h	;non-destuctive compare HL:DE
0738  B7      		ora	a
0739          		dsbc	d
0739  ED52    		DB	0EDH,d*8+42H
073B  E1      		pop	h
073C  C9      		ret
		
		; Convert letters to upper-case
073D          	toupper:
073D  FE61    		cpi	'a'
073F  D8      		rc
0740  FE7B    		cpi	'z'+1
0742  D0      		rnc
0743  E65F    		ani	01011111b
0745  C9      		ret
		
		; Read a line of text into 'line'
		; End with CR, honor BS
		; Reject all non-printing characters, force toupper
0746  2104FF  	linein:	lxi	h,line	;get string of characters from console, ending in CR
0749  CD9E00  	li0:	call	conin	;get a character
074C  FE08    		cpi	BS	;allow BackSpacing
074E          		jrz	backup
074E  281D    		DB	28H,backup-$-1
0750  FE0D    		cpi	CR
0752          		jrz	li1
0752  282E    		DB	28H,li1-$-1
0754  FE03    		cpi	CTLC
0756          		jrz	liZ
0756  2830    		DB	28H,liZ-$-1
0758  FE20    		cpi	' '	;ignore other non-print
075A          		jrc	li0
075A  38ED    		DB	38H,li0-$-1
075C  CD3D07  		call	toupper
075F  77      		mov	m,a	;put character in line nuffer
0760  23      		inx	h
0761  4F      		mov	c,a
0762  CD8F00  		call	conout	; echo character
0765  7D      		mov	a,l	;else check for pending buffer overflow
0766  D604    		sui	line mod 256
0768  FE40    		cpi	64
076A  C8      		rz		;stop if buffer full
076B          		jr	li0	;if not full, keep getting characters
076B  18DC    		DB	18H,li0-$-1
		
076D  7D      	backup:	mov	a,l	;(destructive) BackSpacing
076E  FE04    		cpi	line mod 256	;test if at beginning of line
0770          		jrz	li0	;can't backspace past start of line
0770  28D7    		DB	28H,li0-$-1
0772  0E08    		mvi	c,bs	;output BS," ",BS to erase character on screen
0774  CD8F00  		call	conout	;and put cursor back one position
0777  CD1E07  		call	space
077A  0E08    		mvi	c,bs
077C  CD8F00  		call	conout
077F  2B      		dcx	h	;step buffer pointer back one
0780          		jr	li0	;and continue to get characters
0780  18C7    		DB	18H,li0-$-1
		
		; End line input, A=CR
0782  77      	li1:	mov	m,a	; store CR in buffer
0783  0E0D    		mvi	c,CR	;display CR so user knows we got it
0785  C38F00  		jmp	conout	;then return to calling routine
		
		; Abort input
0788  0E5E    	liZ:	mvi	c,'^'
078A  CD8F00  		call	conout
078D  0E43    		mvi	c,'C'
078F  CD8F00  		call	conout
0792  E1      		pop	h	; always OK?
0793  C9      		ret		; return to caller's caller (main debug loop)
		
		; Get next character from line buffer.
		; DE=current pointer within 'line'
		; Returns: ZR=EOL else A=char
0794  7B      	char:	mov	a,e	;remove a character from line buffer,
0795  D604    		sui	line mod 256	;testing for no more characters
0797  D640    		sui	64
0799  C8      		rz		;return [ZR] condition if at end of buffer
079A  1A      		ldax	d
079B  FE0D    		cpi	CR
079D  C8      		rz		;also return [ZR] if at end of line
079E  13      		inx	d	;else step to next character
079F  C9      		ret		;and return [NZ]
		
		; Get HEX value from line buffer
		; Return: CY=error, HL=value, bit7(B)=1 if no input
07A0          	getaddr:		;extract address from line buffer (delimitted by " ")
07A0          		setb	7,b	;flag to detect no address entered
07A0  CBF8    		DB	0CBH,7*8+b+0C0H
07A2  210000  		lxi	h,0
07A5  CD2B05  		call	skb
07A8  C8      		rz		;end of buffer/line before a character was found
07A9          		jr	ga1	;if not space, then start getting HEX digits
07A9  1804    		DB	18H,ga1-$-1
		
07AB  CD9407  	ga0:	call	char
07AE  C8      		rz
07AF  CDC707  	ga1:	call	hexcon	;start assembling digits into 16 bit accumilator
07B2          		jrc	chkdlm	;check if valid delimiter before returning error.
07B2  380E    		DB	38H,chkdlm-$-1
07B4          		res	7,b	;reset flag
07B4  CBB8    		DB	0CBH,7*8+b+80H
07B6  D5      		push	d	;save buffer pointer
07B7  5F      		mov	e,a
07B8  1600    		mvi	d,0
07BA  29      		dad	h	;shift "accumulator" left 1 digit
07BB  29      		dad	h
07BC  29      		dad	h
07BD  29      		dad	h
07BE  19      		dad	d	;add in new digit
07BF  D1      		pop	d	;restore buffer pointer
07C0          		jr	ga0	;loop for next digit
07C0  18E9    		DB	18H,ga0-$-1
		
07C2  FE20    	chkdlm: cpi	' '	;blank is currently the only valid delimiter
07C4  C8      		rz
07C5  37      		stc
07C6  C9      		ret
		
07C7          	hexcon: 		;convert ASCII character to HEX digit
07C7  FE30    		cpi	'0'	;must be .GE. "0"
07C9  D8      		rc
07CA  FE3A    		cpi	'9'+1	;and be .LE. "9"
07CC          		jrc	ok0	;valid numeral.
07CC  3809    		DB	38H,ok0-$-1
07CE  FE41    		cpi	'A'	;or .GE. "A"
07D0  D8      		rc
07D1  FE47    		cpi	'F'+1	;and .LE. "F"
07D3  3F      		cmc
07D4  D8      		rc		;return [CY] if not valid HEX digit
07D5  D607    		sui	'A'-'9'-1	;convert letter
07D7  D630    	ok0:	sui	'0'	;convert (numeral) to 0-15 in (A)
07D9  C9      		ret
		
		; These only work on */84 (and 10) models.
		; Have no effect (and does nothing) on */83 models.
07DA          	proginit:
07DA  AF      		xra	a
07DB          		stai
07DB  ED47    		DB	0EDH,47H
0000          	 if not rom2k
		 endif
07DD  3E41    		mvi	a,'A'
07DF  320030  		sta	3000h
07E2  C9      		ret
		
07E3          	progoff:
07E3          		ldai
07E3  ED57    		DB	0EDH,57H
07E5  C0      		rnz
07E6  2F      		cma
07E7          		stai
07E7  ED47    		DB	0EDH,47H
0000          	 if not rom2k
		 endif
07E9  AF      		xra	a
07EA  320030  		sta	3000h
07ED  C9      		ret
		
07EE          	progress:
07EE          		ldai
07EE  ED57    		DB	0EDH,57H
07F0  C0      		rnz
0000          	 if not rom2k
		 endif
07F1  3A0030  		lda	3000h
07F4  EE03    		xri	00000011b
07F6  320030  		sta	3000h
07F9  C9      		ret
		
			rept	romsiz-$
07FA  FF      		db	0ffh
07FB  FF      		db	0ffh
07FC  FF      		db	0ffh
07FD  FF      		db	0ffh
07FE  FF      		db	0ffh
07FF  FF      		db	0ffh
0000          	 if $ <> romsiz
		 endif
		
		; RAM used...
FF00          		org	0ff00h
FF00          	addr0:	ds	2
FF02          	addr1:	ds	2
FF04          	line:	ds	64
		
FF44          		end



Statistics:

     4	passes
     0	jr promotions
   189	symbols
  2048	bytes

   274	macro calls
  3775	macro bytes
     0	invented symbols
